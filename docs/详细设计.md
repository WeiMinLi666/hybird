# 混合证书管理系统详细设计

## 摘要

本文档是混合证书管理系统的详细设计文档，基于领域驱动设计（DDD）架构，详细阐述了系统的各个层次和模块的实现细节。本文档从领域模型设计、基础设施层设计、触发层设计、应用层设计、类型层设计、API层设计、核心业务流程、性能优化、安全设计、监控告警、部署指南等方面进行了全面深入的技术阐述。

本文档采用分层架构设计思想，严格遵循依赖倒置原则和单一职责原则，系统划分为六个核心模块：hybird-api（API层）、hybird-trigger（触发层）、hybird-domain（领域层）、hybird-infrastructure（基础设施层）、hybird-types（类型层）、hybird-app（应用层）。每个模块职责明确，接口清晰，实现了业务逻辑与技术实现的彻底解耦。

文档详细描述了系统的六大核心业务域（身份验证域、证书生命周期域、签名域、策略域、证书状态查询域、审计日志域）的领域模型设计，包括聚合根、实体、值对象、领域服务、仓储接口等核心概念。同时，文档还提供了完整的数据库表设计、HTTP接口设计、定时任务设计、领域事件监听器设计等内容，为后续的代码实现提供了详细的技术指导。

**关键词**：混合证书；领域驱动设计；详细设计；系统实现；后量子密码学

---

## 第一章 引言

### 1.1 编写目的

本详细设计文档的主要目的是：

1. **指导代码实现**：为开发团队提供详细的技术实现指导，确保开发过程中遵循统一的架构规范和编码标准
2. **明确接口规范**：定义系统内部各模块之间的接口契约，包括领域服务接口、仓储接口、端口接口等
3. **规范数据库设计**：详细描述数据库表结构、索引设计、SQL映射等内容，指导数据持久化实现
4. **细化业务流程**：详细阐述核心业务流程的实现细节，包括证书申请流程、证书吊销流程、证书链查询流程等
5. **支持系统测试**：提供详细的接口定义和业务逻辑描述，便于测试团队设计和编写测试用例
6. **指导系统部署**：描述系统的配置要求、部署步骤、运维指南等内容，支持生产环境部署

### 1.2 参考文档

- 《混合证书管理系统概要设计文档》
- GB/T 35275-2017 信息安全技术 SM2密码算法使用规范
- RFC 5280 Internet X.509 Public Key Infrastructure Certificate
- RFC 2986 PKCS #10: Certification Request Syntax Specification
- NIST FIPS 203 Module-Lattice-Based Key-Encapsulation Mechanism Standard
- NIST FIPS 204 Module-Lattice-Based Digital Signature Standard
- Domain-Driven Design (Eric Evans)
- 《Spring Boot实战》

---

## 第二章 系统架构实现

### 2.1 分层架构实现

系统采用六层架构设计，严格遵循DDD分层原则，各层之间的依赖关系为单向依赖，从上到下依次为：API层、触发层、领域层、基础设施层、类型层、应用层。

#### 2.1.1 模块结构

系统划分为以下六个核心模块：

| 模块名称 | 包名 | 职责 |
|---------|------|------|
| hybird-api | org.wyman.api | 定义API数据传输对象（DTO）和统一响应格式 |
| hybird-trigger | org.wyman.trigger | 处理HTTP请求、执行定时任务、监听领域事件 |
| hybird-domain | org.wyman.domain | 封装核心业务逻辑，定义领域模型和仓储接口 |
| hybird-infrastructure | org.wyman.infrastructure | 实现仓储接口，提供数据持久化和技术支撑 |
| hybird-types | org.wyman.types | 定义共享类型（枚举、异常、领域事件） |
| hybird-app | org.wyman | 应用启动、配置管理、数据初始化 |

#### 2.1.2 依赖关系

```
hybird-app
    │
    ├─> hybird-trigger
    │       │
    │       ├─> hybird-api ──> hybird-types
    │       │
    │       ├─> hybird-domain ──> hybird-types
    │       │
    │       └─> hybird-infrastructure ──> hybird-domain ──> hybird-types
    │
    └─> hybird-infrastructure ──> hybird-domain ──> hybird-types
```

#### 2.1.3 目录结构

```
hybird/
├── hybird-api/                # API层
│   └── src/main/java/org/wyman/api/
│       ├── dto/               # 数据传输对象
│       ├── request/           # 请求对象
│       ├── response/          # 响应对象
│       └── common/            # 公共类（统一响应格式等）
│
├── hybird-trigger/            # 触发层
│   └── src/main/java/org/wyman/trigger/
│       ├── http/              # HTTP控制器
│       ├── job/               # 定时任务
│       └── listener/          # 领域事件监听器
│
├── hybird-domain/             # 领域层
│   └── src/main/java/org/wyman/domain/
│       ├── authentication/    # 身份验证域
│       │   ├── model/aggregate/
│       │   ├── model/entity/
│       │   ├── valobj/
│       │   ├── service/
│       │   └── adapter/port/
│       ├── lifecycle/          # 证书生命周期域
│       ├── signing/            # 签名域
│       ├── policy/             # 策略域
│       ├── status/             # 证书状态查询域
│       ├── audit/              # 审计日志域
│       └── chain/              # 证书链域
│
├── hybird-infrastructure/     # 基础设施层
│   └── src/main/java/org/wyman/infrastructure/
│       ├── adapter/port/       # 端口实现
│       ├── adapter/repository/ # 仓储实现
│       ├── dao/mapper/         # MyBatis Mapper接口
│       ├── dao/po/             # 持久化对象
│       └── redis/              # Redis实现
│
├── hybird-types/               # 类型层
│   └── src/main/java/org/wyman/types/
│       ├── enums/              # 枚举类型
│       ├── event/              # 领域事件
│       └── exception/          # 异常类
│
└── hybird-app/                 # 应用层
    └── src/main/java/org/wyman/
        ├── Application.java   # 应用启动类
        └── config/             # 配置类
```

---

## 第三章 领域层详细设计

### 3.1 身份验证域设计

#### 3.1.1 聚合根设计

**类名**：`AuthenticationRequest`  
**包路径**：`org.wyman.domain.authentication.model.aggregate.AuthenticationRequest`

**职责**：管理身份验证请求的完整生命周期，包括请求创建、验证、完成、失败等状态流转。

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| requestId | String | 请求ID，唯一标识 |
| applicant | Applicant | 申请者信息 |
| csr | CertificateSigningRequest | 证书签名请求 |
| idToken | String | 身份提供者令牌 |
| status | AuthRequestStatus | 请求状态 |
| failureReason | String | 失败原因 |
| createdAt | LocalDateTime | 创建时间 |
| validatedAt | LocalDateTime | 验证时间 |

**状态流转图**：

```
PENDING_VALIDATION
    │
    ├─> VALIDATION_SUCCESSFUL
    │
    └─> VALIDATION_FAILED
```

**核心方法实现**：

```java
// 启动验证流程
public void startValidation(String idToken, CertificateSigningRequest csr) {
    if (this.status != AuthRequestStatus.PENDING_VALIDATION) {
        throw new IllegalStateException("Authentication request is not pending validation");
    }
    this.idToken = idToken;
    this.csr = csr;
}

// 验证成功
public void completeValidation() {
    if (this.status != AuthRequestStatus.PENDING_VALIDATION) {
        throw new IllegalStateException("Authentication request is not pending validation");
    }
    this.status = AuthRequestStatus.VALIDATION_SUCCESSFUL;
    this.validatedAt = LocalDateTime.now();
    
    // 发布身份验证完成事件
    publishEvent(new AuthenticationCompletedEvent(
        this.requestId,
        this.applicant.getApplicantId(),
        true,
        this.clientIp
    ));
}

// 验证失败
public void failValidation(String reason) {
    if (this.status != AuthRequestStatus.PENDING_VALIDATION) {
        throw new IllegalStateException("Authentication request is not pending validation");
    }
    this.status = AuthRequestStatus.VALIDATION_FAILED;
    this.failureReason = reason;
    this.validatedAt = LocalDateTime.now();
    
    // 发布身份验证完成事件
    publishEvent(new AuthenticationCompletedEvent(
        this.requestId,
        this.applicant.getApplicantId(),
        false,
        this.clientIp
    ));
}
```

**领域事件**：

- `AuthenticationCompletedEvent`：身份验证完成事件，包含请求ID、申请者ID、验证结果、客户端IP等信息

#### 3.1.2 实体设计

**类名**：`Applicant`  
**包路径**：`org.wyman.domain.authentication.model.entity.Applicant`

**职责**：封装申请者信息

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| applicantId | String | 申请者ID |
| applicantName | String | 申请者名称 |
| applicantEmail | String | 申请者邮箱 |

#### 3.1.3 值对象设计

**类名**：`CertificateSigningRequest`  
**包路径**：`org.wyman.domain.authentication.valobj.CertificateSigningRequest`

**职责**：封装证书签名请求（CSR）数据

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| csrPemData | String | CSR PEM格式数据 |
| subjectDN | String | 主题DN |
| publicKeyAlgorithm | String | 公钥算法 |
| isSignatureValid | boolean | 签名是否有效 |

**核心方法**：

```java
// 验证CSR签名
public boolean verifySignature() {
    // 该方法由CSR解析器实现
    return this.isSignatureValid;
}
```

#### 3.1.4 领域服务设计

**类名**：`AuthenticationService`  
**包路径**：`org.wyman.domain.authentication.service.AuthenticationService`

**职责**：处理身份验证请求，协调身份验证流程

**依赖接口**：

- `IAuthenticationRequestRepository`：身份验证请求仓储接口
- `ICSRParser`：CSR解析器接口
- `IIdentityProvider`：身份提供者接口

**核心方法**：

```java
/**
 * 处理身份验证请求
 * @param requestId 请求ID
 * @param applicantId 申请者ID
 * @param idToken 身份提供者令牌
 * @param csrPemData CSR PEM数据
 * @return AuthenticationRequest 验证请求对象
 */
public AuthenticationRequest processAuthentication(
    String requestId,
    String applicantId,
    String idToken,
    String csrPemData
) {
    // 1. 获取申请者信息
    Applicant applicant = identityProvider.validateIdToken(idToken);
    
    // 2. 解析CSR数据
    CertificateSigningRequest csr = csrParser.parseCSR(csrPemData);
    
    // 3. 验证CSR签名
    if (!csr.verifySignature()) {
        throw new AppException("INVALID_CSR", "CSR signature is invalid");
    }
    
    // 4. 创建身份验证请求
    AuthenticationRequest request = new AuthenticationRequest(
        requestId,
        applicant,
        csr
    );
    
    // 5. 验证申请者身份
    if (validateApplicantIdentity(applicant)) {
        request.completeValidation();
    } else {
        request.failValidation("Applicant identity verification failed");
    }
    
    // 6. 保存验证请求
    repository.save(request);
    
    return request;
}
```

**业务流程**：

1. 获取申请者信息
2. 解析CSR数据，提取公钥和主题DN
3. 验证CSR签名有效性
4. 验证密钥算法合规性
5. 创建AuthenticationRequest聚合根
6. 根据验证结果更新请求状态
7. 发布AuthenticationCompletedEvent事件
8. 保存验证请求到仓储

#### 3.1.5 仓储接口设计

**接口名**：`IAuthenticationRequestRepository`  
**包路径**：`org.wyman.domain.authentication.adapter.port.IAuthenticationRequestRepository`

**核心方法**：

```java
public interface IAuthenticationRequestRepository {
    // 保存身份验证请求
    void save(AuthenticationRequest request);
    
    // 根据请求ID查询
    AuthenticationRequest findById(String requestId);
    
    // 根据申请者ID查询
    List<AuthenticationRequest> findByApplicantId(String applicantId);
    
    // 根据状态查询
    List<AuthenticationRequest> findByStatus(AuthRequestStatus status);
}
```

---

### 3.2 证书生命周期域设计

#### 3.2.1 聚合根设计

**类名**：`Certificate`  
**包路径**：`org.wyman.domain.lifecycle.model.aggregate.Certificate`

**职责**：管理证书签发后的动态状态，包括激活、吊销、过期、续期等状态流转

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| serialNumber | String | 证书序列号（主键） |
| certificateType | CertificateType | 证书类型 |
| certificate | Certificate | 证书数据（值对象） |
| status | CertificateStatus | 证书状态 |
| revocationInfo | RevocationInfo | 吊销信息 |
| notificationPolicy | NotificationPolicy | 通知策略 |
| renewalNoticeDays | int | 临期通知天数 |
| createdAt | LocalDateTime | 创建时间 |
| updatedAt | LocalDateTime | 更新时间 |

**状态流转图**：

```
PENDING_ISSUANCE
    │
    └─> ACTIVE
         │
         ├─> REVOKED
         │
         ├─> EXPIRED
         │
         └─> RENEWAL_DUE
```

**核心方法实现**：

```java
// 激活证书
public void activate() {
    if (this.status != CertificateStatus.PENDING_ISSUANCE) {
        throw new IllegalStateException("Certificate is not pending issuance");
    }
    this.status = CertificateStatus.ACTIVE;
    this.updatedAt = LocalDateTime.now();
    
    // 发布证书签发事件
    publishEvent(new CertificateIssuedEvent(
        this.serialNumber,
        this.certificate.getSubjectDN(),
        "SYSTEM",
        this.clientIp
    ));
}

// 吊销证书
public void revoke(RevocationReason reason, String revokedBy, String comments) {
    if (this.status != CertificateStatus.ACTIVE) {
        throw new IllegalStateException("Only active certificates can be revoked");
    }
    this.status = CertificateStatus.REVOKED;
    this.revocationInfo = new RevocationInfo(
        reason,
        revokedBy,
        LocalDateTime.now(),
        comments
    );
    this.updatedAt = LocalDateTime.now();
    
    // 发布证书吊销事件
    publishEvent(new CertificateRevokedEvent(
        this.serialNumber,
        reason,
        revokedBy,
        this.clientIp
    ));
}

// 过期证书
public void expire() {
    if (this.status != CertificateStatus.ACTIVE) {
        throw new IllegalStateException("Only active certificates can be expired");
    }
    this.status = CertificateStatus.EXPIRED;
    this.updatedAt = LocalDateTime.now();
}

// 标记为待续期
public void markForRenewal() {
    if (this.status != CertificateStatus.ACTIVE) {
        throw new IllegalStateException("Only active certificates can be marked for renewal");
    }
    this.status = CertificateStatus.RENEWAL_DUE;
    this.updatedAt = LocalDateTime.now();
    
    // 发布临期通知事件
    publishEvent(new RenewalNoticeDueEvent(
        this.serialNumber,
        this.certificate.getNotAfter()
    ));
}

// 检查是否过期
public boolean isExpired() {
    return LocalDateTime.now().isAfter(
        this.certificate.getNotAfter().toInstant()
            .atZone(ZoneId.systemDefault())
            .toLocalDateTime()
    );
}

// 检查是否需要发送临期通知
public boolean needsRenewalNotice() {
    LocalDateTime expiryDate = this.certificate.getNotAfter().toInstant()
        .atZone(ZoneId.systemDefault())
        .toLocalDateTime();
    LocalDateTime noticeDate = expiryDate.minusDays(this.renewalNoticeDays);
    return LocalDateTime.now().isAfter(noticeDate) 
        && this.status == CertificateStatus.ACTIVE;
}
```

#### 3.2.2 值对象设计

**类名**：`Certificate`  
**包路径**：`org.wyman.domain.lifecycle.valobj.Certificate`

**职责**：封装证书核心数据

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| serialNumber | String | 序列号 |
| subjectDN | String | 主题DN |
| issuerDN | String | 颁发者DN |
| notBefore | Date | 生效时间 |
| notAfter | Date | 失效时间 |
| pemEncoded | String | PEM编码 |
| signatureAlgorithm | SignatureAlgorithm | 签名算法 |
| crlDistributionPoints | String | CRL分发点 |

**类名**：`RevocationInfo`  
**包路径**：`org.wyman.domain.lifecycle.valobj.RevocationInfo`

**职责**：封装吊销信息

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| reason | RevocationReason | 吊销原因 |
| revokedBy | String | 吊销操作人 |
| revokedAt | LocalDateTime | 吊销时间 |
| comments | String | 备注信息 |

**类名**：`NotificationPolicy`  
**包路径**：`org.wyman.domain.lifecycle.valobj.NotificationPolicy`

**职责**：封装通知策略

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| expiryNotificationDays | int | 临期通知天数（默认30天） |
| emailEnabled | boolean | 邮件通知开关 |
| smsEnabled | boolean | 短信通知开关 |

#### 3.2.3 领域服务设计

**类名**：`CertificateLifecycleService`  
**包路径**：`org.wyman.domain.lifecycle.service.CertificateLifecycleService`

**职责**：管理证书生命周期，协调证书激活、吊销、过期、续期等操作

**依赖接口**：

- `ICertificateRepository`：证书仓储接口

**核心方法**：

```java
// 激活证书
public void activateCertificate(String serialNumber) {
    Certificate certificate = repository.findBySerialNumber(serialNumber);
    if (certificate == null) {
        throw new AppException("CERT_NOT_FOUND", "Certificate not found");
    }
    certificate.activate();
    repository.save(certificate);
}

// 吊销证书
public void revokeCertificate(String serialNumber, RevocationReason reason,
                              String revokedBy, String comments) {
    Certificate certificate = repository.findBySerialNumber(serialNumber);
    if (certificate == null) {
        throw new AppException("CERT_NOT_FOUND", "Certificate not found");
    }
    certificate.revoke(reason, revokedBy, comments);
    repository.save(certificate);
}

// 续期证书
public void renewCertificate(String serialNumber) {
    Certificate certificate = repository.findBySerialNumber(serialNumber);
    if (certificate == null) {
        throw new AppException("CERT_NOT_FOUND", "Certificate not found");
    }
    
    // 生成新证书序列号
    String newSerialNumber = generateSerialNumber();
    
    // 创建新证书
    Certificate renewedCertificate = new Certificate(
        newSerialNumber,
        certificate.getCertificateType(),
        certificate.getCertificate(),
        certificate.getNotificationPolicy(),
        certificate.getRenewalNoticeDays()
    );
    
    // 保存新证书
    repository.save(renewedCertificate);
}

// 检查过期证书
public void checkExpiredCertificates() {
    List<Certificate> activeCertificates = repository.findByStatus(CertificateStatus.ACTIVE);
    for (Certificate certificate : activeCertificates) {
        if (certificate.isExpired()) {
            certificate.expire();
            repository.save(certificate);
        }
    }
}

// 扫描并通知临期证书
public void scanAndNotifyExpiringCertificates() {
    List<Certificate> activeCertificates = repository.findByStatus(CertificateStatus.ACTIVE);
    for (Certificate certificate : activeCertificates) {
        if (certificate.needsRenewalNotice()) {
            certificate.markForRenewal();
            repository.save(certificate);
        }
    }
}

// 获取已吊销证书列表
public List<Certificate> getRevokedCertificates() {
    return repository.findByStatus(CertificateStatus.REVOKED);
}
```

**定时任务集成**：

- 每日01:00：执行`checkExpiredCertificates()`，检查并标记过期证书
- 每日08:00：执行`scanAndNotifyExpiringCertificates()`，扫描临期证书并发送通知

---

### 3.3 签名域设计

#### 3.3.1 聚合根设计

**类名**：`CertificateAuthority`  
**包路径**：`org.wyman.domain.signing.model.aggregate.CertificateAuthority`

**职责**：执行数字签名操作，签发证书和CRL

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| caId | String | CA ID |
| caName | String | CA名称（唯一） |
| caDN | String | CA DN |
| certificate | Certificate | CA证书 |
| privateKeyAlias | String | 私钥别名 |
| keyType | String | 密钥类型（SM2/RSA/ECDSA） |
| keySize | int | 密钥长度 |
| enabled | boolean | 是否启用 |

**核心方法实现**：

```java
// 签发证书
public Certificate issueCertificate(
    String subjectDN,
    PublicKey publicKey,
    Date notBefore,
    Date notAfter,
    SignatureAlgorithm signatureAlgorithm,
    String crlDistributionPoints
) {
    if (!this.enabled) {
        throw new IllegalStateException("CA is disabled");
    }
    
    // 1. 生成证书序列号
    String serialNumber = generateSerialNumber();
    
    // 2. 执行签名
    byte[] tbsData = buildTbsCertificateData(
        serialNumber,
        subjectDN,
        publicKey,
        notBefore,
        notAfter,
        crlDistributionPoints
    );
    byte[] signature = performSignature(tbsData, signatureAlgorithm);
    
    // 3. 构建证书
    Certificate certificate = new Certificate(
        serialNumber,
        subjectDN,
        this.caDN,
        publicKey,
        notBefore,
        notAfter,
        signatureAlgorithm,
        signature,
        crlDistributionPoints
    );
    
    return certificate;
}

// 生成CRL
public CRL generateCRL(
    List<RevokedCertificate> revokedCerts,
    SignatureAlgorithm signatureAlgorithm
) {
    // 1. 生成CRL编号
    int crlNumber = this.nextCrlNumber++;
    
    // 2. 构建CRL元数据
    Date thisUpdate = new Date();
    Date nextUpdate = new Date(thisUpdate.getTime() + 24 * 60 * 60 * 1000); // 24小时后
    
    CRLMetadata metadata = new CRLMetadata(
        crlNumber,
        this.caDN,
        thisUpdate,
        nextUpdate
    );
    
    // 3. 执行签名
    byte[] tbsCRLData = buildTbsCRLData(metadata, revokedCerts);
    byte[] signature = performSignature(tbsCRLData, signatureAlgorithm);
    
    // 4. 构建CRL
    CRL crl = new CRL(
        metadata,
        revokedCerts,
        signature
    );
    
    // 5. 发布CRL签发事件
    publishEvent(new CRLIssuedEvent(
        this.caName,
        crlNumber,
        revokedCerts.size(),
        "SYSTEM",
        this.clientIp
    ));
    
    return crl;
}

// 执行签名
private byte[] performSignature(byte[] data, SignatureAlgorithm algorithm) {
    try {
        // 获取私钥
        PrivateKey privateKey = privateKeyProvider.getPrivateKey(this.privateKeyAlias);
        
        // 创建签名器
        Signature signer = getSignatureInstance(algorithm);
        signer.initSign(privateKey);
        signer.update(data);
        
        // 执行签名
        return signer.sign();
    } catch (Exception e) {
        throw new AppException("SIGNATURE_FAILED", "Failed to perform signature", e);
    }
}

// 获取签名实例
private Signature getSignatureInstance(SignatureAlgorithm algorithm) 
    throws NoSuchAlgorithmException, NoSuchProviderException {
    
    Security.addProvider(new BouncyCastleProvider());
    
    switch (algorithm) {
        case SM2:
            return Signature.getInstance("SM3withSM2", BouncyCastleProvider.PROVIDER_NAME);
        case ML_DSA:
            return Signature.getInstance("ML-DSA", BouncyCastleProvider.PROVIDER_NAME);
        case RSA2048:
        case RSA4096:
            return Signature.getInstance("SHA256withRSA", BouncyCastleProvider.PROVIDER_NAME);
        case ECDSA_P256:
            return Signature.getInstance("SHA256withECDSA", BouncyCastleProvider.PROVIDER_NAME);
        default:
            throw new IllegalArgumentException("Unsupported signature algorithm: " + algorithm);
    }
}
```

**关键技术实现**：

1. **Catalyst模型破解签名循环依赖**：使用Builder模式或Factory模式，将证书构建和签名分离
2. **混合签名支持**：支持同时使用传统算法（SM2、RSA、ECDSA）和后量子算法（ML-DSA）进行签名
3. **Bouncy Castle集成**：使用Bouncy Castle密码学库实现SM2、ML-DSA等算法

#### 3.3.2 值对象设计

**类名**：`CRL`  
**包路径**：`org.wyman.domain.signing.valobj.CRL`

**职责**：封装证书吊销列表数据

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| crlNumber | int | CRL编号 |
| issuerDN | String | 颁发者DN |
| thisUpdate | Date | 本次更新时间 |
| nextUpdate | Date | 下次更新时间 |
| revokedCertificates | List<RevokedCertificate> | 吊销证书列表 |
| signature | byte[] | 签名 |

**类名**：`RevokedCertificate`  
**包路径**：`org.wyman.domain.signing.valobj.RevokedCertificate`

**职责**：封装被吊销的证书信息

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| serialNumber | String | 证书序列号 |
| revocationDate | Date | 吊销时间 |
| reason | RevocationReason | 吊销原因 |

#### 3.3.3 领域服务设计

**类名**：`SigningService`  
**包路径**：`org.wyman.domain.signing.service.SigningService`

**职责**：管理签名服务，协调证书签发、CRL生成、CA创建等操作

**依赖接口**：

- `ICertificateAuthorityRepository`：CA仓储接口
- `IPrivateKeyProvider`：私钥提供者接口

**核心方法**：

```java
// 签发证书
public Certificate issueCertificate(
    String caName,
    String subjectDN,
    PublicKey publicKey,
    Date notBefore,
    Date notAfter,
    SignatureAlgorithm signatureAlgorithm,
    String crlDistributionPoints
) {
    // 1. 查询CA
    CertificateAuthority ca = caRepository.findByName(caName);
    if (ca == null) {
        throw new AppException("CA_NOT_FOUND", "CA not found: " + caName);
    }
    
    // 2. 签发证书
    return ca.issueCertificate(
        subjectDN,
        publicKey,
        notBefore,
        notAfter,
        signatureAlgorithm,
        crlDistributionPoints
    );
}

// 生成CRL
public CRL generateCRL(
    String caName,
    List<RevokedCertificate> revokedCerts,
    SignatureAlgorithm signatureAlgorithm
) {
    // 1. 查询CA
    CertificateAuthority ca = caRepository.findByName(caName);
    if (ca == null) {
        throw new AppException("CA_NOT_FOUND", "CA not found: " + caName);
    }
    
    // 2. 生成CRL
    return ca.generateCRL(revokedCerts, signatureAlgorithm);
}

// 创建CA
public CertificateAuthority createCertificateAuthority(
    String caName,
    String caDN,
    String keyType,
    int keySize
) {
    // 1. 生成密钥对
    KeyPair keyPair = generateKeyPair(keyType, keySize);
    
    // 2. 存储私钥
    String privateKeyAlias = "ca_" + caName;
    privateKeyProvider.storePrivateKey(privateKeyAlias, keyPair.getPrivate());
    
    // 3. 创建CA
    CertificateAuthority ca = new CertificateAuthority(
        caName,
        caDN,
        keyPair.getPublic(),
        privateKeyAlias,
        keyType,
        keySize
    );
    
    // 4. 保存CA
    caRepository.save(ca);
    
    return ca;
}

// 获取所有CA
public List<CertificateAuthority> getAllCertificateAuthorities() {
    return caRepository.findAll();
}

// 生成密钥对
private KeyPair generateKeyPair(String keyType, int keySize) {
    try {
        Security.addProvider(new BouncyCastleProvider());
        KeyPairGenerator keyGen;
        
        switch (keyType) {
            case "EC":
                keyGen = KeyPairGenerator.getInstance("EC", BouncyCastleProvider.PROVIDER_NAME);
                keyGen.initialize(new ECNamedCurveSpec("sm2p256v1"));
                break;
            case "RSA":
                keyGen = KeyPairGenerator.getInstance("RSA");
                keyGen.initialize(keySize);
                break;
            default:
                throw new IllegalArgumentException("Unsupported key type: " + keyType);
        }
        
        return keyGen.generateKeyPair();
    } catch (Exception e) {
        throw new AppException("KEYGEN_FAILED", "Failed to generate key pair", e);
    }
}
```

**支持的签名算法**：

- SM2（国密算法）
- ML-DSA（后量子算法，基于模格）
- RSA2048/RSA4096
- ECDSA_P256

---

### 3.4 策略域设计

#### 3.4.1 聚合根设计

**类名**：`CertificatePolicy`  
**包路径**：`org.wyman.domain.policy.model.aggregate.CertificatePolicy`

**职责**：定义和执行证书签发策略，包括密码学规则、有效期规则、主题DN规则

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| policyId | String | 策略ID |
| certificateType | CertificateType | 证书类型 |
| policyName | String | 策略名称 |
| cryptographicRule | CryptographicRule | 密码学规则 |
| validityPeriodRule | ValidityPeriodRule | 有效期规则 |
| subjectDNRule | SubjectDNRule | 主题DN规则 |
| enabled | boolean | 是否启用 |

**核心方法实现**：

```java
// 启用策略
public void enable() {
    this.enabled = true;
}

// 禁用策略
public void disable() {
    this.enabled = false;
}

// 验证密码学参数
public void validateCryptographicParameters(
    SignatureAlgorithm signatureAlgorithm,
    List<String> kemAlgorithms,
    boolean requireHybridSignature
) {
    // 1. 验证签名算法
    if (!cryptographicRule.getAllowedSignatureAlgorithms().contains(signatureAlgorithm)) {
        throw new AppException("INVALID_ALGORITHM", 
            "Signature algorithm not allowed: " + signatureAlgorithm);
    }
    
    // 2. 验证KEM算法
    for (String kemAlgorithm : kemAlgorithms) {
        if (!cryptographicRule.getAllowedKemAlgorithms().contains(kemAlgorithm)) {
            throw new AppException("INVALID_ALGORITHM", 
                "KEM algorithm not allowed: " + kemAlgorithm);
        }
    }
    
    // 3. 验证混合签名要求
    if (cryptographicRule.isRequireHybridSignature() && !requireHybridSignature) {
        throw new AppException("HYBRID_REQUIRED", 
            "Hybrid signature is required by policy");
    }
}

// 验证主题DN
public void validateSubjectDN(String subjectDN) {
    // 1. 验证必填字段
    for (String field : subjectDNRule.getRequiredFields()) {
        if (!subjectDN.contains(field + "=")) {
            throw new AppException("MISSING_FIELD", 
                "Required field missing in subject DN: " + field);
        }
    }
    
    // 2. 验证CN正则表达式
    if (subjectDNRule.getCommonNamePattern() != null) {
        Pattern pattern = Pattern.compile(subjectDNRule.getCommonNamePattern());
        Matcher matcher = pattern.matcher(subjectDN);
        if (!matcher.find()) {
            throw new AppException("INVALID_CN", 
                "Common name does not match the required pattern");
        }
    }
}

// 验证有效期
public void validateValidityPeriod(Date notBefore, Date notAfter) {
    long validityDays = ChronoUnit.DAYS.between(
        notBefore.toInstant(),
        notAfter.toInstant()
    );
    
    if (validityDays < validityPeriodRule.getMinValidityDays()) {
        throw new AppException("VALIDITY_TOO_SHORT", 
            "Validity period is too short: " + validityDays + " days");
    }
    
    if (validityDays > validityPeriodRule.getMaxValidityDays()) {
        throw new AppException("VALIDITY_TOO_LONG", 
            "Validity period is too long: " + validityDays + " days");
    }
}
```

#### 3.4.2 值对象设计

**类名**：`CryptographicRule`  
**包路径**：`org.wyman.domain.policy.valobj.CryptographicRule`

**职责**：封装密码学规则

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| allowedSignatureAlgorithms | List<SignatureAlgorithm> | 允许的签名算法列表 |
| allowedKemAlgorithms | List<String> | 允许的KEM算法列表 |
| minKeySize | int | 最小密钥长度 |
| requireHybridSignature | boolean | 是否要求混合签名 |

**类名**：`ValidityPeriodRule`  
**包路径**：`org.wyman.domain.policy.valobj.ValidityPeriodRule`

**职责**：封装有效期规则

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| minValidityDays | int | 最小有效天数 |
| maxValidityDays | int | 最大有效天数 |

**类名**：`SubjectDNRule`  
**包路径**：`org.wyman.domain.policy.valobj.SubjectDNRule`

**职责**：封装主题DN规则

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| commonNamePattern | String | CN正则表达式 |
| requiredFields | List<String> | 必填字段（CN、O、OU等） |

#### 3.4.3 领域服务设计

**类名**：`PolicyService`  
**包路径**：`org.wyman.domain.policy.service.PolicyService`

**职责**：管理证书策略，协调策略创建、查询、验证等操作

**依赖接口**：

- `ICertificatePolicyRepository`：证书策略仓储接口

**核心方法**：

```java
// 获取证书策略
public CertificatePolicy getPolicyForCertificateType(CertificateType type) {
    List<CertificatePolicy> policies = repository.findByType(type);
    return policies.stream()
        .filter(CertificatePolicy::isEnabled)
        .findFirst()
        .orElseThrow(() -> new AppException("POLICY_NOT_FOUND", 
            "No enabled policy found for certificate type: " + type));
}

// 根据策略验证CSR
public void validateCSRAgainstPolicy(
    CertificateSigningRequest csr,
    CertificatePolicy policy
) {
    // 1. 验证主题DN
    policy.validateSubjectDN(csr.getSubjectDN());
    
    // 2. 验证密钥算法
    SignatureAlgorithm algorithm = SignatureAlgorithm.valueOf(
        csr.getPublicKeyAlgorithm()
    );
    policy.validateCryptographicParameters(
        algorithm,
        Collections.emptyList(),
        false
    );
}

// 创建默认策略
public CertificatePolicy createDefaultPolicy(
    CertificateType type,
    String policyName
) {
    // 1. 创建密码学规则
    CryptographicRule cryptoRule = new CryptographicRule(
        Arrays.asList(SignatureAlgorithm.SM2, SignatureAlgorithm.ML_DSA),
        Arrays.asList("ML-KEM"),
        2048,
        false
    );
    
    // 2. 创建有效期规则
    ValidityPeriodRule validityRule = new ValidityPeriodRule(
        1,    // 最小1天
        365   // 最大365天
    );
    
    // 3. 创建主题DN规则
    SubjectDNRule subjectDNRule = new SubjectDNRule(
        "^[a-zA-Z0-9.-]+$",  // CN正则
        Arrays.asList("CN", "O")  // 必填字段
    );
    
    // 4. 创建策略
    CertificatePolicy policy = new CertificatePolicy(
        UUID.randomUUID().toString(),
        type,
        policyName,
        cryptoRule,
        validityRule,
        subjectDNRule,
        true
    );
    
    // 5. 保存策略
    repository.save(policy);
    
    return policy;
}

// 更新策略
public void updatePolicy(
    String policyId,
    CryptographicRule cryptoRule,
    ValidityPeriodRule validityRule,
    SubjectDNRule subjectDNRule
) {
    CertificatePolicy policy = repository.findById(policyId);
    if (policy == null) {
        throw new AppException("POLICY_NOT_FOUND", "Policy not found: " + policyId);
    }
    
    policy.updateRules(cryptoRule, validityRule, subjectDNRule);
    repository.save(policy);
}
```

---

### 3.5 证书状态查询域设计

#### 3.5.1 聚合根设计

**类名**：`RevocationStatusCache`  
**包路径**：`org.wyman.domain.status.model.aggregate.RevocationStatusCache`

**职责**：提供高性能的证书吊销状态查询，支持Redis缓存和数据库查询

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| cache | Map<String, RevocationDetail> | 吊销状态缓存 |
| crlMetadata | CRLMetadata | CRL元数据 |
| lastUpdateTime | LocalDateTime | 最后更新时间 |

**核心方法实现**：

```java
// 检查证书是否吊销
public boolean isRevoked(String serialNumber) {
    RevocationDetail detail = cache.get(serialNumber);
    return detail != null;
}

// 批量检查
public Map<String, Boolean> batchCheckRevocation(List<String> serialNumbers) {
    Map<String, Boolean> result = new HashMap<>();
    for (String serialNumber : serialNumbers) {
        result.put(serialNumber, isRevoked(serialNumber));
    }
    return result;
}

// 获取吊销详情
public RevocationDetail getRevocationDetail(String serialNumber) {
    return cache.get(serialNumber);
}

// 从CRL更新缓存
public void updateFromCRL(CRLMetadata metadata, List<RevocationDetail> details) {
    this.crlMetadata = metadata;
    this.lastUpdateTime = LocalDateTime.now();
    
    this.cache.clear();
    for (RevocationDetail detail : details) {
        this.cache.put(detail.getSerialNumber(), detail);
    }
}
```

#### 3.5.2 值对象设计

**类名**：`CRLMetadata`  
**包路径**：`org.wyman.domain.status.valobj.CRLMetadata`

**职责**：封装CRL元数据

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| crlNumber | int | CRL编号 |
| issuerDN | String | 颁发者DN |
| thisUpdate | Date | 本次更新时间 |
| nextUpdate | Date | 下次更新时间 |

**类名**：`RevocationDetail`  
**包路径**：`org.wyman.domain.status.valobj.RevocationDetail`

**职责**：封装吊销详情

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| serialNumber | String | 证书序列号 |
| revocationDate | Date | 吊销时间 |
| reason | RevocationReason | 吊销原因 |

#### 3.5.3 领域服务设计

**类名**：`RevocationStatusService`  
**包路径**：`org.wyman.domain.status.service.RevocationStatusService`

**职责**：管理证书吊销状态查询服务，支持缓存和数据库查询

**依赖接口**：

- `IRevocationStatusCacheRepository`：吊销状态缓存仓储接口
- `ICertificateRepository`：证书仓储接口（用于数据库查询）

**核心方法**：

```java
// 检查证书吊销状态
public boolean checkRevocationStatus(String serialNumber) {
    // 1. 尝试从缓存查询
    if (cacheRepository != null) {
        RevocationStatusCache cache = cacheRepository.load();
        if (cache != null) {
            return cache.isRevoked(serialNumber);
        }
    }
    
    // 2. 从数据库查询
    Certificate certificate = certificateRepository.findBySerialNumber(serialNumber);
    return certificate != null && certificate.getStatus() == CertificateStatus.REVOKED;
}

// 批量检查吊销状态
public Map<String, Boolean> batchCheckRevocationStatus(List<String> serialNumbers) {
    // 1. 尝试从缓存查询
    if (cacheRepository != null) {
        RevocationStatusCache cache = cacheRepository.load();
        if (cache != null) {
            return cache.batchCheckRevocation(serialNumbers);
        }
    }
    
    // 2. 从数据库查询
    Map<String, Boolean> result = new HashMap<>();
    for (String serialNumber : serialNumbers) {
        Certificate certificate = certificateRepository.findBySerialNumber(serialNumber);
        result.put(serialNumber, 
            certificate != null && certificate.getStatus() == CertificateStatus.REVOKED);
    }
    return result;
}

// 获取吊销详情
public RevocationDetail getRevocationDetail(String serialNumber) {
    // 1. 尝试从缓存查询
    if (cacheRepository != null) {
        RevocationStatusCache cache = cacheRepository.load();
        if (cache != null) {
            return cache.getRevocationDetail(serialNumber);
        }
    }
    
    // 2. 从数据库查询
    Certificate certificate = certificateRepository.findBySerialNumber(serialNumber);
    if (certificate == null) {
        return null;
    }
    
    if (certificate.getStatus() != CertificateStatus.REVOKED) {
        return null;
    }
    
    return new RevocationDetail(
        serialNumber,
        certificate.getRevocationInfo().getRevokedAt(),
        certificate.getRevocationInfo().getReason()
    );
}

// 从CRL更新缓存
public void updateCacheFromCRL(
    CRLMetadata metadata,
    List<RevocationDetail> revokedDetails
) {
    if (cacheRepository != null) {
        RevocationStatusCache cache = new RevocationStatusCache();
        cache.updateFromCRL(metadata, revokedDetails);
        cacheRepository.save(cache);
    }
}

// 获取缓存统计
public Map<String, Object> getCacheStatistics() {
    if (cacheRepository != null) {
        RevocationStatusCache cache = cacheRepository.load();
        if (cache != null) {
            Map<String, Object> stats = new HashMap<>();
            stats.put("cacheSize", cache.getCache().size());
            stats.put("lastUpdateTime", cache.getLastUpdateTime());
            stats.put("crlNumber", cache.getCrlMetadata().getCrlNumber());
            return stats;
        }
    }
    return Collections.emptyMap();
}
```

---

### 3.6 审计日志域设计

#### 3.6.1 聚合根设计

**类名**：`AuditEvent`  
**包路径**：`org.wyman.domain.audit.model.aggregate.AuditEvent`

**职责**：记录系统关键操作日志，支持完整性验证和审计追溯

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| logId | Long | 日志ID（自增主键） |
| eventType | String | 事件类型 |
| payload | String | 事件数据（JSON） |
| payloadHash | String | 负载哈希（SHA-256） |
| operator | String | 操作人 |
| ipAddress | String | 客户端IP |
| timestamp | TimestampValueObject | 时间戳 |

**核心方法实现**：

```java
// 计算负载哈希值
public void computePayloadHash() {
    try {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        byte[] hash = md.digest(payload.getBytes(StandardCharsets.UTF_8));
        this.payloadHash = Base64.getEncoder().encodeToString(hash);
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException("SHA-256 algorithm not available", e);
    }
}

// 验证负载完整性
public boolean verifyPayloadIntegrity() {
    try {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        byte[] hash = md.digest(payload.getBytes(StandardCharsets.UTF_8));
        String computedHash = Base64.getEncoder().encodeToString(hash);
        return computedHash.equals(this.payloadHash);
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException("SHA-256 algorithm not available", e);
    }
}

// 设置负载并计算哈希
public void setPayloadWithHash(String payload) {
    this.payload = payload;
    computePayloadHash();
}
```

#### 3.6.2 值对象设计

**类名**：`TimestampValueObject`  
**包路径**：`org.wyman.domain.audit.valobj.TimestampValueObject`

**职责**：封装时间戳

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| timestamp | LocalDateTime | 时间戳 |

#### 3.6.3 领域服务设计

**类名**：`AuditService`  
**包路径**：`org.wyman.domain.audit.service.AuditService`

**职责**：管理审计日志服务，记录和查询系统关键操作

**依赖接口**：

- `IAuditEventRepository`：审计事件仓储接口

**核心方法**：

```java
// 记录领域事件
public void logDomainEvent(
    IDomainEvent domainEvent,
    String operator,
    String clientIp
) {
    AuditEvent auditEvent = new AuditEvent();
    auditEvent.setEventType(domainEvent.getClass().getSimpleName());
    auditEvent.setPayload(JsonUtils.toJson(domainEvent));
    auditEvent.setPayloadWithHash(auditEvent.getPayload());
    auditEvent.setOperator(operator);
    auditEvent.setIpAddress(clientIp);
    auditEvent.setTimestamp(new TimestampValueObject(LocalDateTime.now()));
    
    repository.save(auditEvent);
}

// 记录证书签发
public void logCertificateIssuance(
    String serialNumber,
    String subjectDN,
    String operator,
    String clientIp
) {
    Map<String, Object> payload = new HashMap<>();
    payload.put("serialNumber", serialNumber);
    payload.put("subjectDN", subjectDN);
    payload.put("action", "CERTIFICATE_ISSUED");
    
    AuditEvent auditEvent = new AuditEvent();
    auditEvent.setEventType("CERTIFICATE_ISSUANCE");
    auditEvent.setPayload(JsonUtils.toJson(payload));
    auditEvent.setPayloadWithHash(auditEvent.getPayload());
    auditEvent.setOperator(operator);
    auditEvent.setIpAddress(clientIp);
    auditEvent.setTimestamp(new TimestampValueObject(LocalDateTime.now()));
    
    repository.save(auditEvent);
}

// 记录证书吊销
public void logCertificateRevocation(
    String serialNumber,
    RevocationReason reason,
    String operator,
    String clientIp
) {
    Map<String, Object> payload = new HashMap<>();
    payload.put("serialNumber", serialNumber);
    payload.put("reason", reason.name());
    payload.put("action", "CERTIFICATE_REVOKED");
    
    AuditEvent auditEvent = new AuditEvent();
    auditEvent.setEventType("CERTIFICATE_REVOCATION");
    auditEvent.setPayload(JsonUtils.toJson(payload));
    auditEvent.setPayloadWithHash(auditEvent.getPayload());
    auditEvent.setOperator(operator);
    auditEvent.setIpAddress(clientIp);
    auditEvent.setTimestamp(new TimestampValueObject(LocalDateTime.now()));
    
    repository.save(auditEvent);
}

// 记录CRL生成
public void logCRLGeneration(
    String caName,
    int crlNumber,
    int revokedCount,
    String operator,
    String clientIp
) {
    Map<String, Object> payload = new HashMap<>();
    payload.put("caName", caName);
    payload.put("crlNumber", crlNumber);
    payload.put("revokedCount", revokedCount);
    payload.put("action", "CRL_GENERATED");
    
    AuditEvent auditEvent = new AuditEvent();
    auditEvent.setEventType("CRL_GENERATION");
    auditEvent.setPayload(JsonUtils.toJson(payload));
    auditEvent.setPayloadWithHash(auditEvent.getPayload());
    auditEvent.setOperator(operator);
    auditEvent.setIpAddress(clientIp);
    auditEvent.setTimestamp(new TimestampValueObject(LocalDateTime.now()));
    
    repository.save(auditEvent);
}

// 记录身份验证
public void logAuthentication(
    String requestId,
    String applicantId,
    boolean success,
    String operator,
    String clientIp
) {
    Map<String, Object> payload = new HashMap<>();
    payload.put("requestId", requestId);
    payload.put("applicantId", applicantId);
    payload.put("success", success);
    payload.put("action", "AUTHENTICATION");
    
    AuditEvent auditEvent = new AuditEvent();
    auditEvent.setEventType("AUTHENTICATION");
    auditEvent.setPayload(JsonUtils.toJson(payload));
    auditEvent.setPayloadWithHash(auditEvent.getPayload());
    auditEvent.setOperator(operator);
    auditEvent.setIpAddress(clientIp);
    auditEvent.setTimestamp(new TimestampValueObject(LocalDateTime.now()));
    
    repository.save(auditEvent);
}

// 查询审计日志
public List<AuditEvent> queryAuditLogs(
    String eventType,
    LocalDateTime startTime,
    LocalDateTime endTime,
    String operator,
    int page,
    int pageSize
) {
    return repository.query(eventType, startTime, endTime, operator, page, pageSize);
}

// 获取审计统计
public Map<String, Object> getAuditStatistics(
    LocalDateTime startTime,
    LocalDateTime endTime
) {
    List<AuditEvent> events = repository.query(null, startTime, endTime, null, 1, 10000);
    
    Map<String, Object> stats = new HashMap<>();
    stats.put("totalCount", events.size());
    
    // 按事件类型统计
    Map<String, Long> eventCounts = events.stream()
        .collect(Collectors.groupingBy(
            AuditEvent::getEventType,
            Collectors.counting()
        ));
    stats.put("eventCounts", eventCounts);
    
    // 按操作人统计
    Map<String, Long> operatorCounts = events.stream()
        .filter(e -> e.getOperator() != null)
        .collect(Collectors.groupingBy(
            AuditEvent::getOperator,
            Collectors.counting()
        ));
    stats.put("operatorCounts", operatorCounts);
    
    return stats;
}
```

---

### 3.7 证书链域设计

#### 3.7.1 领域服务设计

**类名**：`CertificateChainService`  
**包路径**：`org.wyman.domain.chain.service.CertificateChainService`

**职责**：提供证书链查询服务，构建完整的证书信任链

**依赖接口**：

- `ICertificateRepository`：证书仓储接口

**核心方法**：

```java
// 获取证书链
public List<CertificateChainInfo> getCertificateChain(String serialNumber) {
    List<CertificateChainInfo> chain = new ArrayList<>();
    
    // 1. 查询当前证书
    Certificate certificate = certificateRepository.findBySerialNumber(serialNumber);
    if (certificate == null) {
        throw new AppException("CERT_NOT_FOUND", "Certificate not found: " + serialNumber);
    }
    
    // 2. 递归构建证书链
    buildChain(certificate, chain, 0);
    
    // 3. 反转证书链（从根证书到终端证书）
    Collections.reverse(chain);
    
    return chain;
}

// 递归构建证书链
private void buildChain(Certificate certificate, List<CertificateChainInfo> chain, int level) {
    // 添加当前证书
    CertificateChainInfo info = new CertificateChainInfo();
    info.setSerialNumber(certificate.getSerialNumber());
    info.setSubjectDN(certificate.getCertificate().getSubjectDN());
    info.setIssuerDN(certificate.getCertificate().getIssuerDN());
    info.setCertificatePem(certificate.getCertificate().getPemEncoded());
    info.setLevel(level);
    chain.add(info);
    
    // 检查是否为根证书
    if (certificate.getCertificate().getSubjectDN().equals(
        certificate.getCertificate().getIssuerDN())) {
        return;  // 根证书，递归结束
    }
    
    // 查询上级证书
    Certificate issuerCertificate = certificateRepository.findBySubjectDN(
        certificate.getCertificate().getIssuerDN()
    );
    
    if (issuerCertificate != null) {
        buildChain(issuerCertificate, chain, level + 1);
    }
}
```

#### 3.7.2 内部类设计

**类名**：`CertificateChainInfo`  
**包路径**：`org.wyman.domain.chain.service.CertificateChainService.CertificateChainInfo`

**职责**：封装证书链信息

**核心属性**：

| 属性名 | 类型 | 说明 |
|--------|------|------|
| serialNumber | String | 序列号 |
| subjectDN | String | 主题DN |
| issuerDN | String | 颁发者DN |
| certificatePem | String | 证书PEM |
| level | int | 层级（0为根证书） |

---

## 第四章 基础设施层详细设计

### 4.1 仓储实现设计

#### 4.1.1 CertificateRepository实现

**类名**：`CertificateRepository`  
**包路径**：`org.wyman.infrastructure.adapter.repository.CertificateRepository`

**实现接口**：`ICertificateRepository`

**依赖组件**：

- `CertificateMapper`：MyBatis Mapper接口
- `CertificatePO`：持久化对象

**核心方法实现**：

```java
@Repository
public class CertificateRepository implements ICertificateRepository {
    
    @Autowired
    private CertificateMapper mapper;
    
    @Override
    public void save(Certificate certificate) {
        CertificatePO po = toPO(certificate);
        CertificatePO existing = mapper.selectBySerialNumber(certificate.getSerialNumber());
        if (existing == null) {
            mapper.insert(po);
        } else {
            mapper.updateBySerialNumber(po);
        }
    }
    
    @Override
    public Certificate findBySerialNumber(String serialNumber) {
        CertificatePO po = mapper.selectBySerialNumber(serialNumber);
        return po != null ? toDomain(po) : null;
    }
    
    @Override
    public List<Certificate> findByStatus(CertificateStatus status) {
        List<CertificatePO> pos = mapper.selectByStatus(status.name());
        return pos.stream()
            .map(this::toDomain)
            .collect(Collectors.toList());
    }
    
    @Override
    public List<Certificate> findByApplicantId(String applicantId) {
        List<CertificatePO> pos = mapper.selectByApplicantId(applicantId);
        return pos.stream()
            .map(this::toDomain)
            .collect(Collectors.toList());
    }
    
    @Override
    public Certificate findBySubjectDN(String subjectDN) {
        CertificatePO po = mapper.selectBySubjectDN(subjectDN);
        return po != null ? toDomain(po) : null;
    }
    
    // Domain → PO 转换
    private CertificatePO toPO(Certificate certificate) {
        CertificatePO po = new CertificatePO();
        po.setSerialNumber(certificate.getSerialNumber());
        po.setCertificateType(certificate.getCertificateType().name());
        po.setSubjectDN(certificate.getCertificate().getSubjectDN());
        po.setIssuerDN(certificate.getCertificate().getIssuerDN());
        po.setStatus(certificate.getStatus().name());
        po.setNotBefore(certificate.getCertificate().getNotBefore());
        po.setNotAfter(certificate.getCertificate().getNotAfter());
        po.setPemEncoded(certificate.getCertificate().getPemEncoded());
        po.setApplicantId(certificate.getApplicantId());
        
        if (certificate.getRevocationInfo() != null) {
            po.setRevocationReason(certificate.getRevocationInfo().getReason().name());
            po.setRevokedBy(certificate.getRevocationInfo().getRevokedBy());
            po.setRevokedAt(Timestamp.valueOf(certificate.getRevocationInfo().getRevokedAt()));
            po.setRevocationComments(certificate.getRevocationInfo().getComments());
        }
        
        po.setRenewalNoticeDays(certificate.getRenewalNoticeDays());
        po.setCreatedAt(Timestamp.valueOf(LocalDateTime.now()));
        po.setUpdatedAt(Timestamp.valueOf(LocalDateTime.now()));
        
        return po;
    }
    
    // PO → Domain 转换
    private Certificate toDomain(CertificatePO po) {
        Certificate certificate = new Certificate(
            po.getSerialNumber(),
            CertificateType.valueOf(po.getCertificateType()),
            po.getApplicantId()
        );
        certificate.setStatus(CertificateStatus.valueOf(po.getStatus()));
        
        // 设置证书数据
        Certificate certValue = new Certificate();
        certValue.setSerialNumber(po.getSerialNumber());
        certValue.setSubjectDN(po.getSubjectDN());
        certValue.setIssuerDN(po.getIssuerDN());
        certValue.setNotBefore(po.getNotBefore());
        certValue.setNotAfter(po.getNotAfter());
        certValue.setPemEncoded(po.getPemEncoded());
        certificate.setCertificate(certValue);
        
        // 设置吊销信息
        if (po.getRevocationReason() != null) {
            RevocationInfo revocationInfo = new RevocationInfo();
            revocationInfo.setReason(RevocationReason.valueOf(po.getRevocationReason()));
            revocationInfo.setRevokedBy(po.getRevokedBy());
            revocationInfo.setRevokedAt(po.getRevokedAt().toLocalDateTime());
            revocationInfo.setComments(po.getRevocationComments());
            certificate.setRevocationInfo(revocationInfo);
        }
        
        certificate.setRenewalNoticeDays(po.getRenewalNoticeDays());
        
        return certificate;
    }
}
```

#### 4.1.2 其他仓储实现

其他仓储实现（AuthenticationRequestRepository、CertificatePolicyRepository、CertificateAuthorityRepository、AuditEventRepository、RevocationStatusCacheRepository）遵循相同的设计模式：

1. 实现`ICertificateRepository`等仓储接口
2. 依赖MyBatis Mapper进行数据持久化
3. 提供Domain对象与PO对象的双向转换
4. 实现基础的CRUD操作和业务查询方法

---

### 4.2 MyBatis Mapper设计

#### 4.2.1 CertificateMapper接口

**接口名**：`CertificateMapper`  
**包路径**：`org.wyman.infrastructure.dao.mapper.CertificateMapper`

**核心方法**：

```java
@Mapper
public interface CertificateMapper {
    // 插入证书
    int insert(CertificatePO certificate);
    
    // 根据序列号更新证书
    int updateBySerialNumber(CertificatePO certificate);
    
    // 根据序列号查询证书
    CertificatePO selectBySerialNumber(@Param("serialNumber") String serialNumber);
    
    // 根据状态查询证书
    List<CertificatePO> selectByStatus(@Param("status") String status);
    
    // 根据申请者ID查询证书
    List<CertificatePO> selectByApplicantId(@Param("applicantId") String applicantId);
    
    // 根据主题DN查询证书
    CertificatePO selectBySubjectDN(@Param("subjectDN") String subjectDN);
    
    // 查询临期证书
    List<CertificatePO> selectExpiringCertificates(
        @Param("expiryDate") Date expiryDate
    );
    
    // 批量查询证书
    List<CertificatePO> selectBySerialNumbers(@Param("serialNumbers") List<String> serialNumbers);
}
```

#### 4.2.2 CertificateMapper XML映射

**文件路径**：`hybird-infrastructure/src/main/resources/mapper/CertificateMapper.xml`

**ResultMap定义**：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.wyman.infrastructure.dao.mapper.CertificateMapper">
    
    <resultMap id="BaseResultMap" type="org.wyman.infrastructure.dao.po.CertificatePO">
        <id column="serial_number" property="serialNumber" jdbcType="VARCHAR"/>
        <result column="certificate_type" property="certificateType" jdbcType="VARCHAR"/>
        <result column="subject_dn" property="subjectDN" jdbcType="VARCHAR"/>
        <result column="issuer_dn" property="issuerDN" jdbcType="VARCHAR"/>
        <result column="status" property="status" jdbcType="VARCHAR"/>
        <result column="not_before" property="notBefore" jdbcType="TIMESTAMP"/>
        <result column="not_after" property="notAfter" jdbcType="TIMESTAMP"/>
        <result column="applicant_id" property="applicantId" jdbcType="VARCHAR"/>
        <result column="pem_encoded" property="pemEncoded" jdbcType="LONGVARCHAR"/>
        <result column="revocation_reason" property="revocationReason" jdbcType="VARCHAR"/>
        <result column="revoked_by" property="revokedBy" jdbcType="VARCHAR"/>
        <result column="revoked_at" property="revokedAt" jdbcType="TIMESTAMP"/>
        <result column="revocation_comments" property="revocationComments" jdbcType="VARCHAR"/>
        <result column="renewal_notice_days" property="renewalNoticeDays" jdbcType="INTEGER"/>
        <result column="created_at" property="createdAt" jdbcType="TIMESTAMP"/>
        <result column="updated_at" property="updatedAt" jdbcType="TIMESTAMP"/>
    </resultMap>
    
    <!-- Insert语句 -->
    <insert id="insert" parameterType="org.wyman.infrastructure.dao.po.CertificatePO">
        INSERT INTO certificate (
            serial_number, certificate_type, subject_dn, issuer_dn, status,
            not_before, not_after, applicant_id, pem_encoded,
            revocation_reason, revoked_by, revoked_at, revocation_comments,
            renewal_notice_days, created_at, updated_at
        ) VALUES (
            #{serialNumber}, #{certificateType}, #{subjectDN}, #{issuerDN}, #{status},
            #{notBefore}, #{notAfter}, #{applicantId}, #{pemEncoded},
            #{revocationReason}, #{revokedBy}, #{revokedAt}, #{revocationComments},
            #{renewalNoticeDays}, NOW(), NOW()
        )
    </insert>
    
    <!-- Update语句 -->
    <update id="updateBySerialNumber" parameterType="org.wyman.infrastructure.dao.po.CertificatePO">
        UPDATE certificate SET
            status = #{status},
            revocation_reason = #{revocationReason},
            revoked_by = #{revokedBy},
            revoked_at = #{revokedAt},
            revocation_comments = #{revocationComments},
            updated_at = NOW()
        WHERE serial_number = #{serialNumber}
    </update>
    
    <!-- Select语句 -->
    <select id="selectBySerialNumber" resultMap="BaseResultMap">
        SELECT * FROM certificate
        WHERE serial_number = #{serialNumber}
    </select>
    
    <select id="selectByStatus" resultMap="BaseResultMap">
        SELECT * FROM certificate
        WHERE status = #{status}
        ORDER BY created_at DESC
    </select>
    
    <select id="selectByApplicantId" resultMap="BaseResultMap">
        SELECT * FROM certificate
        WHERE applicant_id = #{applicantId}
        ORDER BY created_at DESC
    </select>
    
    <select id="selectBySubjectDN" resultMap="BaseResultMap">
        SELECT * FROM certificate
        WHERE subject_dn = #{subjectDN}
        LIMIT 1
    </select>
    
    <select id="selectExpiringCertificates" resultMap="BaseResultMap">
        SELECT * FROM certificate
        WHERE status = 'ACTIVE'
        AND DATE_ADD(NOW(), INTERVAL #{expiryDate} DAY) >= not_after
        ORDER BY not_after ASC
    </select>
    
    <select id="selectBySerialNumbers" resultMap="BaseResultMap">
        SELECT * FROM certificate
        WHERE serial_number IN
        <foreach collection="serialNumbers" item="serialNumber" open="(" separator="," close=")">
            #{serialNumber}
        </foreach>
    </select>
    
</mapper>
```

---

### 4.3 端口适配器实现设计

#### 4.3.1 MockPrivateKeyProvider实现

**类名**：`MockPrivateKeyProvider`  
**包路径**：`org.wyman.infrastructure.adapter.port.MockPrivateKeyProvider`

**实现接口**：`IPrivateKeyProvider`

**职责**：提供Mock私钥提供者实现，用于开发和测试环境

**核心方法实现**：

```java
@Component
public class MockPrivateKeyProvider implements IPrivateKeyProvider {
    
    private final Map<String, KeyPair> keyPairCache = new ConcurrentHashMap<>();
    
    @Override
    public PrivateKey getPrivateKey(String alias) {
        KeyPair keyPair = keyPairCache.computeIfAbsent(alias, k -> generateKeyPair());
        return keyPair.getPrivate();
    }
    
    @Override
    public PublicKey getPublicKey(String alias) {
        KeyPair keyPair = keyPairCache.get(alias);
        return keyPair != null ? keyPair.getPublic() : null;
    }
    
    @Override
    public void storePrivateKey(String alias, PrivateKey privateKey) {
        KeyPair keyPair = keyPairCache.get(alias);
        if (keyPair != null) {
            keyPairCache.put(alias, new KeyPair(privateKey, keyPair.getPublic()));
        } else {
            keyPairCache.put(alias, new KeyPair(privateKey, null));
        }
    }
    
    private KeyPair generateKeyPair() {
        try {
            Security.addProvider(new BouncyCastleProvider());
            
            // 默认生成SM2密钥对
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC", "BC");
            keyGen.initialize(new ECNamedCurveSpec("sm2p256v1"));
            return keyGen.generateKeyPair();
        } catch (Exception e) {
            throw new AppException("KEYGEN_FAILED", "Failed to generate key pair", e);
        }
    }
}
```

#### 4.3.2 MockIdentityProvider实现

**类名**：`MockIdentityProvider`  
**包路径**：`org.wyman.infrastructure.adapter.port.MockIdentityProvider`

**实现接口**：`IIdentityProvider`

**职责**：提供Mock身份提供者实现，用于开发和测试环境

**核心方法实现**：

```java
@Component
public class MockIdentityProvider implements IIdentityProvider {
    
    @Override
    public Applicant validateIdToken(String idToken) {
        // 在实际生产环境中，应该调用真实的IdP（如OAuth2、SAML）
        // 这里使用Mock实现，直接返回申请者信息
        
        Applicant applicant = new Applicant();
        applicant.setApplicantId("mock-applicant-" + UUID.randomUUID());
        applicant.setApplicantName("Mock Applicant");
        applicant.setApplicantEmail("mock@example.com");
        
        return applicant;
    }
}
```

#### 4.3.3 MockCSRParser实现

**类名**：`MockCSRParser`  
**包路径**：`org.wyman.infrastructure.adapter.port.MockCSRParser`

**实现接口**：`ICSRParser`

**职责**：提供CSR解析器实现，使用Bouncy Castle库解析PEM格式的CSR

**核心方法实现**：

```java
@Component
public class MockCSRParser implements ICSRParser {
    
    @Override
    public CertificateSigningRequest parseCSR(String csrPemData) {
        try {
            Security.addProvider(new BouncyCastleProvider());
            
            // 从PEM格式解析CSR
            PEMParser parser = new PEMParser(new StringReader(csrPemData));
            PKCS10CertificationRequest csr = (PKCS10CertificationRequest) parser.readObject();
            
            // 提取CSR信息
            CertificateSigningRequest signingRequest = new CertificateSigningRequest();
            signingRequest.setCsrPemData(csrPemData);
            signingRequest.setSubjectDN(csr.getSubject().toString());
            signingRequest.setPublicKeyAlgorithm(
                csr.getSubjectPublicKeyInfo().getAlgorithm().getAlgorithm().getId()
            );
            signingRequest.setSignatureValid(csr.isSignatureValid(new BouncyCastleProvider()));
            
            return signingRequest;
        } catch (Exception e) {
            throw new AppException("CSR_PARSE_FAILED", "Failed to parse CSR", e);
        }
    }
}
```

---

### 4.4 数据库表设计详解

#### 4.4.1 certificate表

**表名**：`certificate`  
**说明**：证书信息表，存储所有证书的基本信息和状态

**DDL**：

```sql
CREATE TABLE certificate (
    serial_number VARCHAR(64) PRIMARY KEY COMMENT '证书序列号',
    certificate_type VARCHAR(32) NOT NULL COMMENT '证书类型',
    subject_dn VARCHAR(512) NOT NULL COMMENT '主题DN',
    issuer_dn VARCHAR(512) NOT NULL COMMENT '颁发者DN',
    status VARCHAR(32) NOT NULL DEFAULT 'PENDING_ISSUANCE' COMMENT '证书状态',
    not_before DATETIME NOT NULL COMMENT '生效时间',
    not_after DATETIME NOT NULL COMMENT '失效时间',
    applicant_id VARCHAR(64) COMMENT '申请者ID',
    pem_encoded TEXT NOT NULL COMMENT '证书PEM编码',
    revocation_reason VARCHAR(32) COMMENT '吊销原因',
    revoked_by VARCHAR(64) COMMENT '吊销操作人',
    revoked_at DATETIME COMMENT '吊销时间',
    revocation_comments TEXT COMMENT '吊销备注',
    renewal_notice_days INT DEFAULT 30 COMMENT '临期通知天数',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_status (status),
    INDEX idx_applicant (applicant_id),
    INDEX idx_expiry (not_after)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='证书信息表';
```

**字段说明**：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| serial_number | VARCHAR(64) | 证书序列号，主键，唯一标识一张证书 |
| certificate_type | VARCHAR(32) | 证书类型（DEVICE_CERT、PLATFORM_CERT、CA_CERT、INTERMEDIATE_CERT） |
| subject_dn | VARCHAR(512) | 证书主题DN，如CN=device.example.com,O=Example Corp,C=CN |
| issuer_dn | VARCHAR(512) | 颁发者DN，如CN=Root CA,O=Example Corp,C=CN |
| status | VARCHAR(32) | 证书状态（PENDING_ISSUANCE、ACTIVE、REVOKED、EXPIRED、RENEWAL_DUE） |
| not_before | DATETIME | 证书生效时间 |
| not_after | DATETIME | 证书失效时间 |
| applicant_id | VARCHAR(64) | 申请者ID |
| pem_encoded | TEXT | 证书PEM格式编码，存储完整的X.509证书 |
| revocation_reason | VARCHAR(32) | 吊销原因（KEY_COMPROMISE、CA_COMPROMISE等） |
| revoked_by | VARCHAR(64) | 吊销操作人 |
| revoked_at | DATETIME | 吊销时间 |
| revocation_comments | TEXT | 吊销备注信息 |
| renewal_notice_days | INT | 临期通知天数（默认30天） |
| created_at | DATETIME | 创建时间 |
| updated_at | DATETIME | 更新时间 |

**索引说明**：

- `PRIMARY KEY`：`serial_number`，主键索引
- `idx_status`：`status`，按状态查询证书
- `idx_applicant`：`applicant_id`，按申请者查询证书
- `idx_expiry`：`not_after`，按过期时间查询临期证书

#### 4.4.2 authentication_request表

**表名**：`authentication_request`  
**说明**：身份验证请求表，存储身份验证请求的详细信息

**DDL**：

```sql
CREATE TABLE authentication_request (
    request_id VARCHAR(64) PRIMARY KEY COMMENT '请求ID',
    applicant_id VARCHAR(64) NOT NULL COMMENT '申请者ID',
    applicant_name VARCHAR(128) NOT NULL COMMENT '申请者名称',
    applicant_email VARCHAR(256) COMMENT '申请者邮箱',
    csr_content TEXT NOT NULL COMMENT 'CSR内容',
    csr_subject_dn VARCHAR(512) NOT NULL COMMENT 'CSR主题DN',
    public_key_algorithm VARCHAR(64) NOT NULL COMMENT '公钥算法',
    status VARCHAR(32) NOT NULL DEFAULT 'PENDING_VALIDATION' COMMENT '请求状态',
    failure_reason TEXT COMMENT '失败原因',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    validated_at DATETIME COMMENT '验证时间',
    INDEX idx_status (status),
    INDEX idx_applicant (applicant_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='身份验证请求表';
```

#### 4.4.3 certificate_policy表

**表名**：`certificate_policy`  
**说明**：证书策略表，存储证书签发策略

**DDL**：

```sql
CREATE TABLE certificate_policy (
    policy_id VARCHAR(64) PRIMARY KEY COMMENT '策略ID',
    certificate_type VARCHAR(32) NOT NULL COMMENT '证书类型',
    policy_name VARCHAR(128) NOT NULL COMMENT '策略名称',
    signature_algorithms TEXT NOT NULL COMMENT '允许的签名算法（JSON）',
    kem_algorithms TEXT COMMENT '允许的KEM算法（JSON）',
    require_hybrid_signature BOOLEAN DEFAULT FALSE COMMENT '是否要求混合签名',
    min_validity_days INT NOT NULL COMMENT '最小有效天数',
    max_validity_days INT NOT NULL COMMENT '最大有效天数',
    subject_dn_pattern VARCHAR(512) COMMENT '主题DN正则表达式',
    enabled BOOLEAN NOT NULL DEFAULT TRUE COMMENT '是否启用',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    UNIQUE KEY uk_name_type (policy_name, certificate_type),
    INDEX idx_type_enabled (certificate_type, enabled)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='证书策略表';
```

#### 4.4.4 certificate_authority表

**表名**：`certificate_authority`  
**说明**：CA证书表，存储证书颁发机构的信息

**DDL**：

```sql
CREATE TABLE certificate_authority (
    ca_id VARCHAR(64) PRIMARY KEY COMMENT 'CA ID',
    ca_name VARCHAR(128) NOT NULL UNIQUE COMMENT 'CA名称',
    ca_dn VARCHAR(512) NOT NULL COMMENT 'CA DN',
    certificate_pem TEXT NOT NULL COMMENT 'CA证书PEM',
    private_key_alias VARCHAR(64) NOT NULL COMMENT '私钥别名',
    key_type VARCHAR(32) NOT NULL COMMENT '密钥类型',
    key_size INT NOT NULL COMMENT '密钥长度',
    enabled BOOLEAN NOT NULL DEFAULT TRUE COMMENT '是否启用',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='证书颁发机构表';
```

#### 4.4.5 audit_log表

**表名**：`audit_log`  
**说明**：审计日志表，存储系统所有关键操作的审计日志

**DDL**：

```sql
CREATE TABLE audit_log (
    log_id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '日志ID',
    event_type VARCHAR(64) NOT NULL COMMENT '事件类型',
    event_data TEXT NOT NULL COMMENT '事件数据（JSON）',
    payload_hash VARCHAR(64) NOT NULL COMMENT '负载哈希（SHA-256）',
    operator VARCHAR(64) COMMENT '操作人',
    ip_address VARCHAR(45) COMMENT '客户端IP',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    INDEX idx_event_type (event_type),
    INDEX idx_operator (operator),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='审计日志表';
```

#### 4.4.6 certificate_chain表

**表名**：`certificate_chain`  
**说明**：证书链表，存储证书之间的层级关系

**DDL**：

```sql
CREATE TABLE certificate_chain (
    chain_id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '链ID',
    certificate_serial_number VARCHAR(64) NOT NULL COMMENT '证书序列号',
    parent_serial_number VARCHAR(64) COMMENT '父证书序列号',
    level INT NOT NULL COMMENT '层级（0为根证书）',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    INDEX idx_serial (certificate_serial_number),
    INDEX idx_parent (parent_serial_number)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='证书链表';
```

#### 4.4.7 revocation_status_cache表

**表名**：`revocation_status_cache`  
**说明**：吊销状态缓存表，存储证书吊销状态缓存数据

**DDL**：

```sql
CREATE TABLE revocation_status_cache (
    cache_id VARCHAR(64) PRIMARY KEY COMMENT '缓存ID',
    cache_data TEXT NOT NULL COMMENT '缓存数据（JSON）',
    version INT NOT NULL COMMENT '版本号',
    is_latest BOOLEAN NOT NULL DEFAULT FALSE COMMENT '是否为最新版本',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='吊销状态缓存表';
```

---

## 第五章 触发层详细设计

### 5.1 HTTP控制器设计

#### 5.1.1 CertificateController控制器

**类名**：`CertificateController`  
**包路径**：`org.wyman.trigger.http.CertificateController`

**职责**：处理证书相关的HTTP请求，包括证书申请、查询、吊销、续期等

**映射路径**：`/api/certificate`

**核心方法实现**：

```java
@RestController
@RequestMapping("/api/certificate")
@Slf4j
public class CertificateController {
    
    @Autowired
    private AuthenticationService authenticationService;
    
    @Autowired
    private PolicyService policyService;
    
    @Autowired
    private SigningService signingService;
    
    @Autowired
    private CertificateLifecycleService lifecycleService;
    
    @Autowired
    private CertificateChainService chainService;
    
    @Autowired
    private RevocationStatusService revocationStatusService;
    
    /**
     * 申请证书
     */
    @PostMapping("/apply")
    public Response<CertificateIssuanceResponse> applyCertificate(
        @RequestBody CertificateApplyRequest request
    ) {
        log.info("Received certificate apply request: requestId={}", request.getRequestId());
        
        // 1. 处理身份验证
        AuthenticationRequest authRequest = authenticationService.processAuthentication(
            request.getRequestId(),
            request.getApplicantId(),
            request.getIdToken(),
            request.getCsrPemData()
        );
        
        // 2. 获取证书策略
        CertificatePolicy policy = policyService.getPolicyForCertificateType(
            request.getCertificateType()
        );
        
        // 3. 签发证书
        Certificate certificate = signingService.issueCertificate(
            request.getCaName(),
            request.getSubjectDN(),
            authRequest.getCsr().getPublicKey(),
            request.getNotBefore(),
            request.getNotAfter(),
            request.getSignatureAlgorithm(),
            request.getCrlDistributionPoints()
        );
        
        // 4. 返回响应
        CertificateIssuanceResponse response = new CertificateIssuanceResponse();
        response.setSerialNumber(certificate.getSerialNumber());
        response.setCertificatePem(certificate.getCertificate().getPemEncoded());
        
        return Response.success(response);
    }
    
    /**
     * 申请混合证书
     */
    @PostMapping("/apply/hybrid")
    public Response<CertificateIssuanceResponse> applyHybridCertificate(
        @RequestBody HybridCertificateApplyRequest request
    ) {
        log.info("Received hybrid certificate apply request: requestId={}", request.getRequestId());
        
        // 1. 处理身份验证
        AuthenticationRequest authRequest = authenticationService.processAuthentication(
            request.getRequestId(),
            request.getApplicantId(),
            request.getIdToken(),
            request.getCsrPemData()
        );
        
        // 2. 签发混合证书
        Certificate certificate = signingService.issueCertificate(
            request.getCaName(),
            request.getSubjectDN(),
            authRequest.getCsr().getPublicKey(),
            request.getNotBefore(),
            request.getNotAfter(),
            request.getPrimarySignatureAlgorithm(),
            request.getCrlDistributionPoints()
        );
        
        // 3. 返回响应
        CertificateIssuanceResponse response = new CertificateIssuanceResponse();
        response.setSerialNumber(certificate.getSerialNumber());
        response.setCertificatePem(certificate.getCertificate().getPemEncoded());
        response.setSignatureAlgorithm(request.getPrimarySignatureAlgorithm());
        
        return Response.success(response);
    }
    
    /**
     * 查询证书
     */
    @GetMapping("/query")
    public Response<CertificateQueryResponse> queryCertificate(
        @RequestParam String serialNumber
    ) {
        log.info("Received certificate query request: serialNumber={}", serialNumber);
        
        Certificate certificate = certificateRepository.findBySerialNumber(serialNumber);
        
        if (certificate == null) {
            return Response.error("9999", "Certificate not found");
        }
        
        CertificateQueryResponse response = new CertificateQueryResponse();
        response.setSerialNumber(certificate.getSerialNumber());
        response.setCertificateType(certificate.getCertificateType().name());
        response.setSubjectDN(certificate.getCertificate().getSubjectDN());
        response.setIssuerDN(certificate.getCertificate().getIssuerDN());
        response.setStatus(certificate.getStatus().name());
        response.setNotBefore(certificate.getCertificate().getNotBefore());
        response.setNotAfter(certificate.getCertificate().getNotAfter());
        response.setPemEncoded(certificate.getCertificate().getPemEncoded());
        
        if (certificate.getStatus() == CertificateStatus.REVOKED) {
            response.setRevocationReason(certificate.getRevocationInfo().getReason().name());
            response.setRevokedBy(certificate.getRevocationInfo().getRevokedBy());
            response.setRevokedAt(certificate.getRevocationInfo().getRevokedAt());
        }
        
        return Response.success(response);
    }
    
    /**
     * 查询证书链
     */
    @GetMapping("/chain")
    public Response<CertificateChainResponse> queryCertificateChain(
        @RequestParam String serialNumber
    ) {
        log.info("Received certificate chain query request: serialNumber={}", serialNumber);
        
        List<CertificateChainInfo> chain = chainService.getCertificateChain(serialNumber);
        
        CertificateChainResponse response = new CertificateChainResponse();
        response.setSerialNumber(serialNumber);
        response.setChainSize(chain.size());
        response.setChain(chain);
        
        return Response.success(response);
    }
    
    /**
     * 查询设备证书
     */
    @GetMapping("/device")
    public Response<List<CertificateQueryResponse>> queryDeviceCertificates(
        @RequestParam String applicantId
    ) {
        log.info("Received device certificates query request: applicantId={}", applicantId);
        
        List<Certificate> certificates = certificateRepository.findByApplicantId(applicantId);
        
        List<Certificate> deviceCertificates = certificates.stream()
            .filter(cert -> cert.getCertificateType() == CertificateType.DEVICE_CERT)
            .collect(Collectors.toList());
        
        List<CertificateQueryResponse> responseList = deviceCertificates.stream()
            .map(cert -> {
                CertificateQueryResponse response = new CertificateQueryResponse();
                response.setSerialNumber(cert.getSerialNumber());
                response.setSubjectDN(cert.getCertificate().getSubjectDN());
                response.setStatus(cert.getStatus().name());
                response.setNotBefore(cert.getCertificate().getNotBefore());
                response.setNotAfter(cert.getCertificate().getNotAfter());
                return response;
            })
            .collect(Collectors.toList());
        
        return Response.success(responseList);
    }
    
    /**
     * 吊销证书
     */
    @PostMapping("/revoke")
    public Response<Void> revokeCertificate(
        @RequestBody CertificateRevocationRequest request
    ) {
        log.info("Received certificate revocation request: serialNumber={}", request.getSerialNumber());
        
        lifecycleService.revokeCertificate(
            request.getSerialNumber(),
            request.getRevocationReason(),
            request.getRevokedBy(),
            request.getComments()
        );
        
        return Response.success(null);
    }
    
    /**
     * 续期证书
     */
    @PostMapping("/renew")
    public Response<CertificateIssuanceResponse> renewCertificate(
        @RequestBody CertificateRenewalRequest request
    ) {
        log.info("Received certificate renewal request: serialNumber={}", request.getSerialNumber());
        
        lifecycleService.renewCertificate(request.getSerialNumber());
        
        Certificate renewedCertificate = certificateRepository.findBySerialNumber(
            request.getSerialNumber()
        );
        
        CertificateIssuanceResponse response = new CertificateIssuanceResponse();
        response.setSerialNumber(renewedCertificate.getSerialNumber());
        response.setCertificatePem(renewedCertificate.getCertificate().getPemEncoded());
        
        return Response.success(response);
    }
    
    /**
     * 查询证书吊销状态
     */
    @PostMapping("/status")
    public Response<CertificateStatusCheckResponse> checkCertificateStatus(
        @RequestBody CertificateStatusCheckRequest request
    ) {
        log.info("Received certificate status check request: serialNumber={}", request.getSerialNumber());
        
        boolean isRevoked = revocationStatusService.checkRevocationStatus(
            request.getSerialNumber()
        );
        
        RevocationDetail detail = revocationStatusService.getRevocationDetail(
            request.getSerialNumber()
        );
        
        CertificateStatusCheckResponse response = new CertificateStatusCheckResponse();
        response.setSerialNumber(request.getSerialNumber());
        response.setRevoked(isRevoked);
        
        if (detail != null) {
            response.setRevocationDate(detail.getRevocationDate());
            response.setRevocationReason(detail.getReason().name());
        }
        
        return Response.success(response);
    }
    
    /**
     * 生成CRL
     */
    @PostMapping("/crl/generate")
    public Response<CRLGenerateResponse> generateCRL(
        @RequestBody CRLGenerateRequest request
    ) {
        log.info("Received CRL generation request: caName={}", request.getCaName());
        
        List<Certificate> revokedCertificates = lifecycleService.getRevokedCertificates();
        
        List<RevokedCertificate> revokedCertList = revokedCertificates.stream()
            .map(cert -> {
                RevokedCertificate rc = new RevokedCertificate();
                rc.setSerialNumber(cert.getSerialNumber());
                rc.setRevocationDate(cert.getRevocationInfo().getRevokedAt());
                rc.setReason(cert.getRevocationInfo().getReason());
                return rc;
            })
            .collect(Collectors.toList());
        
        CRL crl = signingService.generateCRL(
            request.getCaName(),
            revokedCertList,
            request.getSignatureAlgorithm()
        );
        
        revocationStatusService.updateCacheFromCRL(
            crl.getCrlMetadata(),
            revokedCertList.stream()
                .map(rc -> {
                    RevocationDetail detail = new RevocationDetail();
                    detail.setSerialNumber(rc.getSerialNumber());
                    detail.setRevocationDate(rc.getRevocationDate());
                    detail.setReason(rc.getReason());
                    return detail;
                })
                .collect(Collectors.toList())
        );
        
        CRLGenerateResponse response = new CRLGenerateResponse();
        response.setCrlNumber(crl.getCrlNumber());
        response.setCrlPem(Base64.getEncoder().encodeToString(crl.getSignature()));
        response.setRevokedCount(revokedCertList.size());
        response.setThisUpdate(crl.getCrlMetadata().getThisUpdate());
        response.setNextUpdate(crl.getCrlMetadata().getNextUpdate());
        
        return Response.success(response);
    }
}
```

#### 5.1.2 其他控制器设计

其他控制器（AuthenticationController、PolicyController、CAController、AuditController）遵循相同的设计模式：

1. 使用`@RestController`和`@RequestMapping`注解定义REST控制器
2. 使用`@Autowired`注入所需的服务
3. 调用领域服务处理业务逻辑
4. 使用统一的`Response`格式返回响应
5. 使用`@Slf4j`记录日志

---

### 5.2 定时任务设计

#### 5.2.1 CertificateExpiryCheckJob定时任务

**类名**：`CertificateExpiryCheckJob`  
**包路径**：`org.wyman.trigger.job.CertificateExpiryCheckJob`

**职责**：检查过期证书和临期证书

**核心方法实现**：

```java
@Component
@Slf4j
public class CertificateExpiryCheckJob {
    
    @Autowired
    private CertificateLifecycleService lifecycleService;
    
    /**
     * 每日01:00检查过期证书
     */
    @Scheduled(cron = "0 0 1 * * ?")
    public void checkExpiredCertificates() {
        log.info("Starting expired certificates check job");
        
        try {
            lifecycleService.checkExpiredCertificates();
            log.info("Completed expired certificates check job");
        } catch (Exception e) {
            log.error("Failed to check expired certificates", e);
        }
    }
    
    /**
     * 每日08:00扫描临期证书并发送通知
     */
    @Scheduled(cron = "0 0 8 * * ?")
    public void scanExpiringCertificates() {
        log.info("Starting expiring certificates notification job");
        
        try {
            lifecycleService.scanAndNotifyExpiringCertificates();
            log.info("Completed expiring certificates notification job");
        } catch (Exception e) {
            log.error("Failed to scan expiring certificates", e);
        }
    }
}
```

#### 5.2.2 CRLUpdateJob定时任务

**类名**：`CRLUpdateJob`  
**包路径**：`org.wyman.trigger.job.CRLUpdateJob`

**职责**：更新CRL和吊销状态缓存

**核心方法实现**：

```java
@Component
@Slf4j
public class CRLUpdateJob {
    
    @Autowired
    private SigningService signingService;
    
    @Autowired
    private RevocationStatusService revocationStatusService;
    
    @Autowired
    private CertificateLifecycleService lifecycleService;
    
    /**
     * 每日02:00更新CRL
     */
    @Scheduled(cron = "0 0 2 * * ?")
    public void updateCRL() {
        log.info("Starting CRL update job");
        
        try {
            // 1. 获取所有启用的CA
            List<CertificateAuthority> cas = signingService.getAllCertificateAuthorities()
                .stream()
                .filter(CertificateAuthority::isEnabled)
                .collect(Collectors.toList());
            
            // 2. 为每个CA生成CRL
            for (CertificateAuthority ca : cas) {
                List<Certificate> revokedCertificates =
                    lifecycleService.getRevokedCertificates();
                
                List<RevokedCertificate> revokedCertList = revokedCertificates.stream()
                    .map(cert -> {
                        RevokedCertificate rc = new RevokedCertificate();
                        rc.setSerialNumber(cert.getSerialNumber());
                        rc.setRevocationDate(cert.getRevocationInfo().getRevokedAt());
                        rc.setReason(cert.getRevocationInfo().getReason());
                        return rc;
                    })
                    .collect(Collectors.toList());
                
                // 生成CRL
                CRL crl = signingService.generateCRL(
                    ca.getCaName(),
                    revokedCertList,
                    SignatureAlgorithm.SM2
                );
                
                // 更新吊销状态缓存
                revocationStatusService.updateCacheFromCRL(
                    crl.getCrlMetadata(),
                    revokedCertList.stream()
                        .map(rc -> {
                            RevocationDetail detail = new RevocationDetail();
                            detail.setSerialNumber(rc.getSerialNumber());
                            detail.setRevocationDate(rc.getRevocationDate());
                            detail.setReason(rc.getReason());
                            return detail;
                        })
                        .collect(Collectors.toList())
                );
            }
            
            log.info("Completed CRL update job");
        } catch (Exception e) {
            log.error("Failed to update CRL", e);
        }
    }
}
```

---

### 5.3 领域事件监听器设计

#### 5.3.1 DomainEventListener监听器

**类名**：`DomainEventListener`  
**包路径**：`org.wyman.trigger.listener.DomainEventListener`

**职责**：监听领域事件并处理，主要用于记录审计日志

**核心方法实现**：

```java
@Component
@Slf4j
public class DomainEventListener {
    
    @Autowired
    private AuditService auditService;
    
    /**
     * 处理身份验证完成事件
     */
    @Async
    @EventListener
    public void handleAuthenticationCompletedEvent(AuthenticationCompletedEvent event) {
        log.info("Handling AuthenticationCompletedEvent: {}", event.getRequestId());
        
        auditService.logAuthentication(
            event.getRequestId(),
            event.getApplicantId(),
            event.isSuccess(),
            "SYSTEM",
            event.getClientIp()
        );
    }
    
    /**
     * 处理证书签发事件
     */
    @Async
    @EventListener
    public void handleCertificateIssuedEvent(CertificateIssuedEvent event) {
        log.info("Handling CertificateIssuedEvent: {}", event.getSerialNumber());
        
        auditService.logCertificateIssuance(
            event.getSerialNumber(),
            event.getSubjectDN(),
            event.getOperator(),
            event.getClientIp()
        );
    }
    
    /**
     * 处理证书吊销事件
     */
    @Async
    @EventListener
    public void handleCertificateRevokedEvent(CertificateRevokedEvent event) {
        log.info("Handling CertificateRevokedEvent: {}", event.getSerialNumber());
        
        auditService.logCertificateRevocation(
            event.getSerialNumber(),
            event.getReason(),
            event.getRevokedBy(),
            event.getClientIp()
        );
    }
    
    /**
     * 处理CRL签发事件
     */
    @Async
    @EventListener
    public void handleCRLIssuedEvent(CRLIssuedEvent event) {
        log.info("Handling CRLIssuedEvent: CA={}, CRL Number={}",
                 event.getCaName(), event.getCrlNumber());
        
        auditService.logCRLGeneration(
            event.getCaName(),
            event.getCrlNumber(),
            event.getRevokedCount(),
            event.getOperator(),
            event.getClientIp()
        );
    }
    
    /**
     * 处理证书临期通知事件
     */
    @Async
    @EventListener
    public void handleRenewalNoticeDueEvent(RenewalNoticeDueEvent event) {
        log.info("Handling RenewalNoticeDueEvent: {}", event.getSerialNumber());
        
        // 记录临期通知审计日志
        AuditEvent noticeEvent = new AuditEvent();
        noticeEvent.setEventType("RENEWAL_NOTICE");
        noticeEvent.setPayload(String.format(
            "Certificate %s is expiring soon",
            event.getSerialNumber()
        ));
        noticeEvent.setPayloadWithHash(noticeEvent.getPayload());
        noticeEvent.setOperator("SYSTEM");
        noticeEvent.setTimestamp(new TimestampValueObject(LocalDateTime.now()));
        
        auditService.save(noticeEvent);
    }
}
```

---

## 第六章 应用层详细设计

### 6.1 配置类设计

#### 6.1.1 DomainConfig配置类

**类名**：`DomainConfig`  
**包路径**：`org.wyman.config.DomainConfig`

**职责**：配置领域服务Bean

**核心方法实现**：

```java
@Configuration
public class DomainConfig {
    
    @Bean
    public AuthenticationService authenticationService(
        IAuthenticationRequestRepository authRequestRepository,
        ICSRParser csrParser,
        IIdentityProvider identityProvider
    ) {
        return new AuthenticationService(
            authRequestRepository,
            csrParser,
            identityProvider
        );
    }
    
    @Bean
    public CertificateLifecycleService certificateLifecycleService(
        ICertificateRepository certificateRepository
    ) {
        return new CertificateLifecycleService(certificateRepository);
    }
    
    @Bean
    public SigningService signingService(
        ICertificateAuthorityRepository caRepository,
        IPrivateKeyProvider privateKeyProvider
    ) {
        return new SigningService(caRepository, privateKeyProvider);
    }
    
    @Bean
    public PolicyService policyService(
        ICertificatePolicyRepository policyRepository
    ) {
        return new PolicyService(policyRepository);
    }
    
    @Bean
    public RevocationStatusService revocationStatusService(
        IRevocationStatusCacheRepository cacheRepository
    ) {
        return new RevocationStatusService(cacheRepository);
    }
    
    @Bean
    public AuditService auditService(
        IAuditEventRepository auditEventRepository
    ) {
        return new AuditService(auditEventRepository);
    }
    
    @Bean
    public CertificateChainService certificateChainService(
        ICertificateRepository certificateRepository
    ) {
        return new CertificateChainService(certificateRepository);
    }
}
```

#### 6.1.2 RedisConfig配置类

**类名**：`RedisConfig`  
**包路径**：`org.wyman.config.RedisConfig`

**职责**：配置Redis缓存

**核心方法实现**：

```java
@Configuration
@ConditionalOnCacheType("redis")
public class RedisConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        StringRedisTemplate template = new StringRedisTemplate(factory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.afterPropertiesSet();
        return template;
    }
    
    @Bean
    @ConditionalOnCacheType("redis")
    public IRevocationStatusCacheRepository revocationStatusCacheRepository(
        RedisTemplate<String, Object> redisTemplate
    ) {
        return new RevocationStatusCacheRepository(redisTemplate);
    }
}
```

#### 6.1.3 ThreadPoolConfig配置类

**类名**：`ThreadPoolConfig`  
**包路径**：`org.wyman.config.ThreadPoolConfig`

**职责**：配置线程池，用于异步处理领域事件

**核心方法实现**：

```java
@Configuration
@EnableAsync
public class ThreadPoolConfig {
    
    @Autowired
    private ThreadPoolConfigProperties properties;
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(properties.getCorePoolSize());
        executor.setMaxPoolSize(properties.getMaxPoolSize());
        executor.setQueueCapacity(properties.getQueueCapacity());
        executor.setThreadNamePrefix("async-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}
```

#### 6.1.4 SchedulingConfig配置类

**类名**：`SchedulingConfig`  
**包路径**：`org.wyman.config.SchedulingConfig`

**职责**：启用定时任务

**核心方法实现**：

```java
@Configuration
@EnableScheduling
public class SchedulingConfig {
}
```

---

### 6.2 数据初始化设计

#### 6.2.1 DataInitializer初始化器

**类名**：`DataInitializer`  
**包路径**：`org.wyman.config.DataInitializer`

**职责**：初始化默认数据，包括默认证书策略和默认CA

**核心方法实现**：

```java
@Component
@Slf4j
public class DataInitializer implements CommandLineRunner {
    
    @Autowired
    private PolicyService policyService;
    
    @Autowired
    private SigningService signingService;
    
    @Override
    public void run(String... args) throws Exception {
        log.info("Initializing default data...");
        
        // 1. 初始化默认证书策略
        initializeDefaultPolicies();
        
        // 2. 初始化默认CA
        initializeDefaultCA();
        
        log.info("Default data initialization completed");
    }
    
    private void initializeDefaultPolicies() {
        // 设备证书策略
        CertificatePolicy devicePolicy = policyService.createDefaultPolicy(
            CertificateType.DEVICE_CERT,
            "Default Device Certificate Policy"
        );
        devicePolicy.enable();
        policyService.save(devicePolicy);
        log.info("Created default device certificate policy");
        
        // 平台证书策略
        CertificatePolicy platformPolicy = policyService.createDefaultPolicy(
            CertificateType.PLATFORM_CERT,
            "Default Platform Certificate Policy"
        );
        platformPolicy.enable();
        policyService.save(platformPolicy);
        log.info("Created default platform certificate policy");
    }
    
    private void initializeDefaultCA() {
        // 创建根CA
        CertificateAuthority rootCA = signingService.createCertificateAuthority(
            "root-ca",
            "CN=Root CA,O=Example Corp,C=CN",
            "EC",
            256
        );
        rootCA.activate();
        log.info("Created root CA");
        
        // 创建中级CA
        CertificateAuthority intermediateCA = signingService.createCertificateAuthority(
            "intermediate-ca",
            "CN=Intermediate CA,O=Example Corp,C=CN",
            "EC",
            256
        );
        intermediateCA.activate();
        log.info("Created intermediate CA");
    }
}
```

---

## 第七章 API层详细设计

### 7.1 DTO对象设计

#### 7.1.1 证书相关DTO

**CertificateApplyRequest**：

```java
public class CertificateApplyRequest {
    private String requestId;
    private String applicantId;
    private String idToken;
    private String csrPemData;
    private String subjectDN;
    private String caName;
    private SignatureAlgorithm signatureAlgorithm;
    private Date notBefore;
    private Date notAfter;
    private String crlDistributionPoints;
    
    // getters and setters
}
```

**CertificateIssuanceResponse**：

```java
public class CertificateIssuanceResponse {
    private String serialNumber;
    private String certificatePem;
    private SignatureAlgorithm signatureAlgorithm;
    
    // getters and setters
}
```

**CertificateQueryResponse**：

```java
public class CertificateQueryResponse {
    private String serialNumber;
    private String certificateType;
    private String subjectDN;
    private String issuerDN;
    private String status;
    private Date notBefore;
    private Date notAfter;
    private String pemEncoded;
    private String revocationReason;
    private String revokedBy;
    private LocalDateTime revokedAt;
    
    // getters and setters
}
```

**CertificateRevocationRequest**：

```java
public class CertificateRevocationRequest {
    private String serialNumber;
    private RevocationReason revocationReason;
    private String revokedBy;
    private String comments;
    
    // getters and setters
}
```

**CertificateStatusCheckResponse**：

```java
public class CertificateStatusCheckResponse {
    private String serialNumber;
    private boolean revoked;
    private Date revocationDate;
    private String revocationReason;
    
    // getters and setters
}
```

#### 7.1.2 统一响应格式

**Response**：

```java
public class Response<T> {
    private String code;
    private String info;
    private T data;
    
    public static <T> Response<T> success(T data) {
        Response<T> response = new Response<>();
        response.setCode("0000");
        response.setInfo("success");
        response.setData(data);
        return response;
    }
    
    public static <T> Response<T> error(String code, String info) {
        Response<T> response = new Response<>();
        response.setCode(code);
        response.setInfo(info);
        return response;
    }
    
    // getters and setters
}
```

---

## 第八章 类型层详细设计

### 8.1 枚举类型设计

#### 8.1.1 CertificateStatus枚举

**类名**：`CertificateStatus`  
**包路径**：`org.wyman.types.enums.CertificateStatus`

**枚举值**：

```java
public enum CertificateStatus {
    PENDING_ISSUANCE,  // 待签发
    ACTIVE,            // 激活
    REVOKED,           // 已吊销
    EXPIRED,           // 已过期
    RENEWAL_DUE        // 待续期
}
```

#### 8.1.2 CertificateType枚举

**类名**：`CertificateType`  
**包路径**：`org.wyman.types.enums.CertificateType`

**枚举值**：

```java
public enum CertificateType {
    DEVICE_CERT,       // 设备证书
    PLATFORM_CERT,     // 平台证书
    CA_CERT,           // CA根证书
    INTERMEDIATE_CERT  // 中级证书
}
```

#### 8.1.3 SignatureAlgorithm枚举

**类名**：`SignatureAlgorithm`  
**包路径**：`org.wyman.types.enums.SignatureAlgorithm`

**枚举值**：

```java
public enum SignatureAlgorithm {
    SM2,               // 国密SM2签名算法
    ML_DSA,            // 后量子ML-DSA签名算法
    RSA2048,           // RSA 2048位签名算法
    RSA4096,           // RSA 4096位签名算法
    ECDSA_P256         // ECDSA P-256曲线
}
```

#### 8.1.4 RevocationReason枚举

**类名**：`RevocationReason`  
**包路径**：`org.wyman.types.enums.RevocationReason`

**枚举值**：

```java
public enum RevocationReason {
    KEY_COMPROMISE,        // 密钥泄露
    CA_COMPROMISE,         // CA泄露
    AFFILIATION_CHANGED,   // 隶属关系变更
    SUPERSEDED,            // 已被替代
    CESSATION_OF_OPERATION,// 停止运营
    CERTIFICATE_HOLD,      // 证书挂起
    REMOVE_FROM_CRL,       // 从CRL中移除
    PRIVILEGE_WITHDRAWN,   // 权限撤销
    AA_COMPROMISE          // AA泄露
}
```

---

### 8.2 领域事件设计

#### 8.2.1 BaseDomainEvent抽象基类

**类名**：`BaseDomainEvent`  
**包路径**：`org.wyman.types.event.BaseDomainEvent`

**实现接口**：`IDomainEvent`

**核心属性**：

```java
public abstract class BaseDomainEvent implements IDomainEvent {
    private String eventId;
    private LocalDateTime occurredOn;
    
    public BaseDomainEvent() {
        this.eventId = UUID.randomUUID().toString();
        this.occurredOn = LocalDateTime.now();
    }
    
    @Override
    public String getEventId() {
        return eventId;
    }
    
    @Override
    public LocalDateTime getOccurredOn() {
        return occurredOn;
    }
    
    // getters and setters
}
```

#### 8.2.2 具体领域事件

**AuthenticationCompletedEvent**：

```java
public class AuthenticationCompletedEvent extends BaseDomainEvent {
    private String requestId;
    private String applicantId;
    private boolean success;
    private String clientIp;
    
    public AuthenticationCompletedEvent(String requestId, String applicantId,
                                       boolean success, String clientIp) {
        this.requestId = requestId;
        this.applicantId = applicantId;
        this.success = success;
        this.clientIp = clientIp;
    }
    
    // getters
}
```

**CertificateIssuedEvent**：

```java
public class CertificateIssuedEvent extends BaseDomainEvent {
    private String serialNumber;
    private String subjectDN;
    private String operator;
    private String clientIp;
    
    public CertificateIssuedEvent(String serialNumber, String subjectDN,
                                 String operator, String clientIp) {
        this.serialNumber = serialNumber;
        this.subjectDN = subjectDN;
        this.operator = operator;
        this.clientIp = clientIp;
    }
    
    // getters
}
```

**CertificateRevokedEvent**：

```java
public class CertificateRevokedEvent extends BaseDomainEvent {
    private String serialNumber;
    private RevocationReason reason;
    private String revokedBy;
    private String clientIp;
    
    public CertificateRevokedEvent(String serialNumber, RevocationReason reason,
                                  String revokedBy, String clientIp) {
        this.serialNumber = serialNumber;
        this.reason = reason;
        this.revokedBy = revokedBy;
        this.clientIp = clientIp;
    }
    
    // getters
}
```

**CRLIssuedEvent**：

```java
public class CRLIssuedEvent extends BaseDomainEvent {
    private String caName;
    private int crlNumber;
    private int revokedCount;
    private String operator;
    private String clientIp;
    
    public CRLIssuedEvent(String caName, int crlNumber, int revokedCount,
                         String operator, String clientIp) {
        this.caName = caName;
        this.crlNumber = crlNumber;
        this.revokedCount = revokedCount;
        this.operator = operator;
        this.clientIp = clientIp;
    }
    
    // getters
}
```

**RenewalNoticeDueEvent**：

```java
public class RenewalNoticeDueEvent extends BaseDomainEvent {
    private String serialNumber;
    private Date expiryDate;
    
    public RenewalNoticeDueEvent(String serialNumber, Date expiryDate) {
        this.serialNumber = serialNumber;
        this.expiryDate = expiryDate;
    }
    
    // getters
}
```

---

### 8.3 异常类设计

#### 8.3.1 AppException异常类

**类名**：`AppException`  
**包路径**：`org.wyman.types.exception.AppException`

**继承**：`RuntimeException`

**核心属性**：

```java
public class AppException extends RuntimeException {
    private String errorCode;
    
    public AppException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
    
    public AppException(String errorCode, String message, Throwable cause) {
        super(message, cause);
        this.errorCode = errorCode;
    }
    
    public String getErrorCode() {
        return errorCode;
    }
    
    // getters and setters
}
```

---

## 第九章 性能优化设计

### 9.1 缓存策略设计

#### 9.1.1 Redis缓存设计

**缓存对象**：证书吊销状态

**缓存配置**：

- **缓存类型**：可配置（redis / database）
- **缓存过期**：24小时自动刷新
- **缓存更新**：CRL更新时同步更新
- **缓存降级**：Redis故障时自动降级为数据库查询

**实现类**：`RevocationStatusCacheRepository`

**核心方法**：

```java
@Repository
public class RevocationStatusCacheRepository implements IRevocationStatusCacheRepository {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String CACHE_KEY = "revocation:cache";
    
    @Override
    public void save(RevocationStatusCache cache) {
        String cacheData = JSON.toJSONString(cache);
        redisTemplate.opsForValue().set(CACHE_KEY, cacheData, 24, TimeUnit.HOURS);
    }
    
    @Override
    public RevocationStatusCache load() {
        String cacheData = (String) redisTemplate.opsForValue().get(CACHE_KEY);
        return cacheData != null ? JSON.parseObject(cacheData, RevocationStatusCache.class) : null;
    }
}
```

#### 9.1.2 Guava缓存设计

**缓存对象**：证书策略

**缓存配置**：

- **缓存过期**：1小时自动刷新
- **缓存容量**：最多1000条策略

**实现类**：`PolicyCache`

**核心方法**：

```java
@Component
public class PolicyCache {
    
    private final LoadingCache<String, CertificatePolicy> cache;
    
    public PolicyCache(PolicyService policyService) {
        this.cache = CacheBuilder.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(1, TimeUnit.HOURS)
            .build(new CacheLoader<String, CertificatePolicy>() {
                @Override
                public CertificatePolicy load(String policyId) {
                    return policyService.getPolicyById(policyId);
                }
            });
    }
    
    public CertificatePolicy get(String policyId) {
        try {
            return cache.get(policyId);
        } catch (ExecutionException e) {
            throw new AppException("CACHE_ERROR", "Failed to load policy from cache", e);
        }
    }
    
    public void invalidate(String policyId) {
        cache.invalidate(policyId);
    }
    
    public void invalidateAll() {
        cache.invalidateAll();
    }
}
```

---

### 9.2 数据库优化设计

#### 9.2.1 索引设计

**certificate表索引**：

- `PRIMARY KEY`：`serial_number`，主键索引
- `idx_status`：`status`，按状态查询证书
- `idx_applicant`：`applicant_id`，按申请者查询证书
- `idx_expiry`：`not_after`，按过期时间查询临期证书

**authentication_request表索引**：

- `PRIMARY KEY`：`request_id`，主键索引
- `idx_status`：`status`，按状态查询
- `idx_applicant`：`applicant_id`，按申请者查询

**certificate_policy表索引**：

- `PRIMARY KEY`：`policy_id`，主键索引
- `uk_name_type`：`policy_name, certificate_type`，策略名称和类型唯一
- `idx_type_enabled`：`certificate_type, enabled`，按类型和启用状态查询

**audit_log表索引**：

- `PRIMARY KEY`：`log_id`，主键索引
- `idx_event_type`：`event_type`，按事件类型查询
- `idx_operator`：`operator`，按操作人查询
- `idx_created_at`：`created_at`，按创建时间查询

**certificate_chain表索引**：

- `PRIMARY KEY`：`chain_id`，主键索引
- `idx_serial`：`certificate_serial_number`，按证书序列号查询
- `idx_parent`：`parent_serial_number`，按父证书序列号查询

---

### 9.3 查询优化设计

#### 9.3.1 批量查询设计

**批量检查吊销状态**：

```java
@Override
public Map<String, Boolean> batchCheckRevocationStatus(List<String> serialNumbers) {
    // 1. 尝试从缓存批量查询
    if (cacheRepository != null) {
        RevocationStatusCache cache = cacheRepository.load();
        if (cache != null) {
            return cache.batchCheckRevocation(serialNumbers);
        }
    }
    
    // 2. 从数据库批量查询
    Map<String, Boolean> result = new HashMap<>();
    List<CertificatePO> certificates = mapper.selectBySerialNumbers(serialNumbers);
    
    for (CertificatePO cert : certificates) {
        result.put(cert.getSerialNumber(),
            CertificateStatus.REVOKED.name().equals(cert.getStatus()));
    }
    
    return result;
}
```

#### 9.3.2 分页查询设计

**分页查询审计日志**：

```java
@Override
public List<AuditEvent> queryAuditLogs(String eventType, LocalDateTime startTime,
                                      LocalDateTime endTime, String operator,
                                      int page, int pageSize) {
    return mapper.selectByConditions(
        eventType, startTime, endTime, operator,
        (page - 1) * pageSize, pageSize
    );
}
```

---

## 第十章 安全设计

### 10.1 通信安全设计

#### 10.1.1 HTTPS/TLS加密

- 所有API通信使用HTTPS加密
- 客户端验证服务器证书
- 支持双向TLS认证（可选）

#### 10.1.2 JWT签名验证

- IdP令牌使用JWT签名
- 验证JWT签名有效性
- 验证JWT令牌过期时间

---

### 10.2 数据安全设计

#### 10.2.1 敏感信息加密

**私钥加密**：使用AES-256加密存储

**证书PEM**：使用Base64编码存储

**IdP令牌**：JWT签名验证

#### 10.2.2 密码学算法

- **签名算法**：SM2、ML-DSA、RSA、ECDSA
- **哈希算法**：SHA-256
- **加密算法**：AES-256

---

### 10.3 访问控制设计

- **基于角色的访问控制（RBAC）**
- **IP白名单**：限制访问来源
- **操作审计**：记录所有关键操作

---

## 第十一章 监控和告警设计

### 11.1 关键指标设计

- 证书数量
- 过期证书数量
- 临期证书数量
- 吊销证书数量
- 证书签发成功率
- API响应时间
- 错误率

---

### 11.2 告警规则设计

- 证书即将过期（30天内）
- 证书已过期
- 证书签发失败率 > 5%
- API响应时间 > 500ms
- Redis连接失败
- 数据库连接失败

---

## 第十二章 部署指南

### 12.1 环境要求

- JDK 17+
- MySQL 8.0+
- Redis 7.x+
- Maven 3.x+

---

### 12.2 配置文件设计

#### 12.2.1 application-dev.yml

```yaml
spring:
  datasource:
    url: jdbc:mysql://49.233.215.82:3306/hybird?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
    username: admin
    password: wyman1112
    driver-class-name: com.mysql.cj.jdbc.Driver

  data:
    redis:
      host: 49.233.215.82
      port: 6379
      password: wyman1112
      database: 0
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0
          max-wait: -1ms

cache:
  type: redis
```

---

### 12.3 启动步骤设计

1. 执行数据库初始化脚本：
   ```bash
   mysql -u admin -p hybird < docs/schema.sql
   ```

2. 编译项目：
   ```bash
   mvn clean package
   ```

3. 启动应用：
   ```bash
   java -jar hybird-app/target/hybird-app-1.0.0.jar
   ```

---

## 第十三章 测试指南

### 13.1 单元测试设计

- 领域层单元测试
- 服务层单元测试
- 仓储层单元测试

---

### 13.2 集成测试设计

- API集成测试
- 数据库集成测试
- Redis集成测试

---

### 13.3 性能测试设计

- 证书签发性能测试
- 证书查询性能测试
- 批量吊销状态查询性能测试

---

## 附录

### 附录A 代码统计

| 模块 | Java文件数 | 代码行数 |
|------|-----------|---------|
| hybird-domain | 35 | ~5000 |
| hybird-app | 13 | ~1000 |
| hybird-infrastructure | 30 | ~4000 |
| hybird-trigger | 8 | ~2000 |
| hybird-types | 16 | ~500 |
| hybird-api | 24 | ~800 |
| **总计** | **126** | **~13300** |

---

### 附录B 参考资料

- GB/T 35275-2017 信息安全技术 SM2密码算法使用规范
- RFC 5280 Internet X.509 Public Key Infrastructure Certificate
- RFC 2986 PKCS #10: Certification Request Syntax Specification
- NIST FIPS 203 Module-Lattice-Based Key-Encapsulation Mechanism Standard
- NIST FIPS 204 Module-Lattice-Based Digital Signature Standard
- Domain-Driven Design (Eric Evans)
- 《Spring Boot实战》
- 《Effective Java》

---

**文档修订历史**

| 版本 | 修订日期 | 修订人 | 修订内容 |
|------|---------|--------|---------|
| V1.0 | 2025-01-04 | 开发团队 | 初始版本 |

---

**文档审批**

| 角色 | 姓名 | 签名 | 日期 |
|------|------|------|------|
| 项目经理 | | | |
| 技术负责人 | | | |
| 测试负责人 | | | |

---

*本文档结束*
