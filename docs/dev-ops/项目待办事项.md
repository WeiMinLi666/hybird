# 混合证书管理系统 - 项目待办事项

**项目名称**: 混合证书管理系统 (Hybrid Certificate Management System)
**文档版本**: V1.0
**创建日期**: 2025-01-04
**最后更新**: 2025-01-04

---

## 目录

- [一、TODO注释任务](#一todo注释任务)
- [二、简化实现任务](#二简化实现任务)
- [三、配置优化任务](#三配置优化任务)
- [四、功能增强任务](#四功能增强任务)
- [五、性能优化任务](#五性能优化任务)
- [六、安全增强任务](#六安全增强任务)
- [七、测试任务](#七测试任务)
- [八、文档完善任务](#八文档完善任务)
- [九、部署运维任务](#九部署运维任务)
- [十、优先级划分](#十优先级划分)

---

## 一、TODO注释任务

### 1.1 CRL更新定时任务 [P0] ✅ 已完成

**状态**: 已完成 (2026-01-07)

**任务ID**: TODO-001
**文件**: `hybird-trigger/src/main/java/org/wyman/trigger/job/CRLUpdateJob.java:21`
**当前代码**:
```java
@Scheduled(cron = "0 0 2 * * ?")
public void updateCRL() {
    log.info("开始更新CRL");
    try {
        // TODO: 调用signing服务生成最新CRL
        log.info("CRL更新完成");
    } catch (Exception e) {
        log.error("更新CRL失败", e);
    }
}
```

**实现方案**:
1. 注入 `SigningService` 和 `CertificateLifecycleService`
2. 查询所有启用的CA
3. 为每个CA查询已吊销的证书
4. 调用 `SigningService.generateCRL()` 生成CRL
5. 发布 `CRLIssuedEvent` 事件
6. 更新吊销状态缓存

**实现代码**:
```java
@Autowired
private SigningService signingService;

@Autowired
private CertificateLifecycleService lifecycleService;

@Autowired
private CertificateAuthorityRepository caRepository;

@Scheduled(cron = "0 0 2 * * ?")
public void updateCRL() {
    log.info("开始更新CRL");
    try {
        // 查询所有启用的CA
        List<CertificateAuthority> caList = caRepository.findAll().stream()
            .filter(CertificateAuthority::isEnabled)
            .toList();

        for (CertificateAuthority ca : caList) {
            // 查询已吊销证书
            List<Certificate> revokedCerts = lifecycleService.getRevokedCertificatesByCA(ca.getCaId());

            // 转换为RevokedCertificate列表
            List<RevokedCertificate> revokedList = revokedCerts.stream()
                .map(cert -> new RevokedCertificate(
                    cert.getSerialNumber(),
                    cert.getRevocationInfo().getRevocationTime(),
                    cert.getRevocationInfo().getRevocationReason()
                ))
                .toList();

            // 生成CRL
            signingService.generateCRL(
                ca.getCaName(),
                revokedList,
                "SM2"
            );
        }

        log.info("CRL更新完成");
    } catch (Exception e) {
        log.error("更新CRL失败", e);
    }
}
```

**依赖任务**: 无
**预计工时**: 4小时
**验收标准**:
- [ ] 每日凌晨2点自动执行
- [ ] 成功生成所有CA的CRL
- [ ] 发布CRLIssuedEvent事件
- [ ] 有完整的异常处理和日志记录

---

### 1.2 CRL签发事件处理 - 缓存更新 [P1]

**任务ID**: TODO-002
**文件**: `hybird-trigger/src/main/java/org/wyman/trigger/listener/DomainEventListener.java:100`
**当前代码**:
```java
@Async
@EventListener
public void handleCRLIssuedEvent(CRLIssuedEvent event) {
    log.info("处理CRL签发事件: crlNumber={}, revokedCount={}",
        event.getCrlNumber(), event.getRevokedCount());
    try {
        auditService.logCRLGeneration(...);

        // TODO: 调用RevocationStatusService更新缓存
    } catch (Exception e) {
        log.error("处理CRL签发事件失败", e);
    }
}
```

**实现方案**:
1. 注入 `RevocationStatusService`
2. 调用 `updateCacheFromCRL()` 方法更新缓存

**实现代码**:
```java
@Autowired
private RevocationStatusService revocationStatusService;

@Async
@EventListener
public void handleCRLIssuedEvent(CRLIssuedEvent event) {
    log.info("处理CRL签发事件: crlNumber={}, revokedCount={}",
        event.getCrlNumber(), event.getRevokedCount());
    try {
        auditService.logCRLGeneration(
            event.getCrlNumber(),
            event.getCrlUrl(),
            event.getRevokedCount(),
            "SYSTEM"
        );

        // 更新吊销状态缓存
        revocationStatusService.updateCacheFromCRL(event.getCrlUrl());
        log.info("吊销状态缓存已更新: crlNumber={}", event.getCrlNumber());
    } catch (Exception e) {
        log.error("处理CRL签发事件失败", e);
    }
}
```

**依赖任务**: TODO-004 (RevocationStatusService需要实现updateCacheFromCRL方法)
**预计工时**: 1小时
**验收标准**:
- [ ] CRL生成后自动更新缓存
- [ ] 缓存更新有日志记录
- [ ] 更新失败有异常处理

---

### 1.3 证书临期通知 - 通知服务缺失 [P2]

**任务ID**: TODO-003
**文件**: `hybird-trigger/src/main/java/org/wyman/trigger/listener/DomainEventListener.java:115`
**当前代码**:
```java
@Async
@EventListener
public void handleRenewalNoticeDueEvent(RenewalNoticeDueEvent event) {
    log.info("处理证书临期通知事件: serialNumber={}, days={}",
        event.getCertificateSerial(), event.getDaysUntilExpiry());
    try {
        // TODO: 发送邮件或短信通知
        log.info("证书临期通知已发送: serialNumber={}", event.getCertificateSerial());
    } catch (Exception e) {
        log.error("发送临期通知失败", e);
    }
}
```

**实现方案**:
1. 创建 `NotificationService` 领域服务
2. 集成邮件服务 (JavaMail/Spring Mail)
3. 集成短信服务 (阿里云/腾讯云)
4. 从证书查询中获取申请者邮箱和手机号
5. 发送通知并记录审计日志

**实现步骤**:
1. 在 `hybird-domain` 创建 `notification` 包
2. 创建 `INotificationService` 接口
3. 创建 `NotificationService` 实现
4. 在 `hybird-infrastructure` 实现邮件和短信适配器
5. 在 `DomainEventListener` 中集成

**依赖任务**: 无
**预计工时**: 16小时
**验收标准**:
- [ ] 支持邮件通知
- [ ] 支持短信通知
- [ ] 通知内容包含证书信息、过期时间
- [ ] 记录通知发送审计日志
- [ ] 发送失败有重试机制

---

## 二、简化实现任务

### 2.1 对象存储网关 - MinIO集成 [P0] ✅ 已完成

**状态**: 已完成 (2026-01-07)

**任务ID**: SIMPL-001
**文件**: `hybird-infrastructure/src/main/java/org/wyman/infrastructure/adapter/port/MockObjectStorageGateway.java`
**当前状态**: 模拟实现，返回假URL和假内容

**实现方案**:
1. 引入 MinIO SDK 依赖
2. 实现真实的文件上传、下载、删除
3. 支持CRL文件存储
4. 支持证书文件备份

**依赖添加**:
```xml
<dependency>
    <groupId>io.minio</groupId>
    <artifactId>minio</artifactId>
    <version>8.5.7</version>
</dependency>
```

**配置添加**:
```yaml
minio:
  endpoint: http://minio.example.com:9000
  access-key: minioadmin
  secret-key: minioadmin
  bucket-name: hybird-certificates
  crl-path: crl/
  cert-path: certificates/
```

**实现代码**:
```java
@Service
public class MinioObjectStorageGateway implements IObjectStorageGateway {

    private final MinioClient minioClient;
    private final String bucketName;
    private final String crlPath;
    private final String certPath;

    public MinioObjectStorageGateway(MinioConfig config) {
        this.minioClient = MinioClient.builder()
            .endpoint(config.getEndpoint())
            .credentials(config.getAccessKey(), config.getSecretKey())
            .build();
        this.bucketName = config.getBucketName();
        this.crlPath = config.getCrlPath();
        this.certPath = config.getCertPath();
        ensureBucketExists();
    }

    private void ensureBucketExists() {
        try {
            if (!minioClient.bucketExists(BucketExistsArgs.builder()
                    .bucket(bucketName).build())) {
                minioClient.makeBucket(MakeBucketArgs.builder()
                        .bucket(bucketName).build());
            }
        } catch (Exception e) {
            throw new RuntimeException("创建MinIO bucket失败", e);
        }
    }

    @Override
    public String uploadCRL(String crlNumber, String crlPem) {
        try {
            String objectName = crlPath + "crl-" + crlNumber + ".crl";
            minioClient.putObject(
                PutObjectArgs.builder()
                    .bucket(bucketName)
                    .object(objectName)
                    .contentType("application/pkix-crl")
                    .stream(
                        new ByteArrayInputStream(crlPem.getBytes()),
                        crlPem.getBytes().length,
                        -1
                    )
                    .build()
            );
            return minioClient.getPresignedObjectUrl(
                GetPresignedObjectUrlArgs.builder()
                    .bucket(bucketName)
                    .object(objectName)
                    .expiry(7, TimeUnit.DAYS)
                    .build()
            );
        } catch (Exception e) {
            throw new RuntimeException("上传CRL到MinIO失败", e);
        }
    }

    @Override
    public String downloadCRL(String crlUrl) {
        try {
            String objectName = extractObjectNameFromUrl(crlUrl);
            return IOUtils.toString(
                minioClient.getObject(
                    GetObjectArgs.builder()
                        .bucket(bucketName)
                        .object(objectName)
                        .build()
                ),
                StandardCharsets.UTF_8
            );
        } catch (Exception e) {
            throw new RuntimeException("从MinIO下载CRL失败", e);
        }
    }

    @Override
    public void deleteCRL(String crlUrl) {
        try {
            String objectName = extractObjectNameFromUrl(crlUrl);
            minioClient.removeObject(
                RemoveObjectArgs.builder()
                    .bucket(bucketName)
                    .object(objectName)
                    .build()
            );
        } catch (Exception e) {
            throw new RuntimeException("从MinIO删除CRL失败", e);
        }
    }

    private String extractObjectNameFromUrl(String url) {
        // 从URL中提取对象名称
        return url.substring(url.indexOf(bucketName) + bucketName.length() + 1);
    }
}
```

**依赖任务**: 无
**预计工时**: 8小时
**验收标准**:
- [ ] 成功上传CRL到MinIO
- [ ] 成功下载CRL内容
- [ ] 成功删除CRL
- [ ] 生成有效的访问URL
- [ ] 异常处理完善

---

### 2.2 身份提供者 - LDAP/OAuth2集成 [P1]

**任务ID**: SIMPL-002
**文件**: `hybird-infrastructure/src/main/java/org/wyman/infrastructure/adapter/port/MockIdentityProvider.java`
**当前状态**: 模拟实现，所有token都通过

**实现方案**:
1. 支持LDAP集成
2. 支持OAuth2集成
3. 支持JWT token解析和验证
4. 实现真实的用户信息查询

**依赖添加**:
```xml
<!-- LDAP -->
<dependency>
    <groupId>org.springframework.ldap</groupId>
    <artifactId>spring-ldap-core</artifactId>
</dependency>

<!-- OAuth2 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>

<!-- JWT -->
<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>java-jwt</artifactId>
    <version>4.4.0</version>
</dependency>
```

**配置添加**:
```yaml
identity:
  provider: ldap
  ldap:
    url: ldap://ldap.example.com:389
    base-dn: dc=example,dc=com
    username: cn=admin,dc=example,dc=com
    password: password
    user-search-base: ou=users
    user-search-filter: (uid={0})
  oauth2:
    issuer-uri: https://auth.example.com
    client-id: client-id
    client-secret: client-secret
    jwk-set-uri: https://auth.example.com/.well-known/jwks.json
```

**实现代码**:
```java
@Service
@ConditionalOnProperty(name = "identity.provider", havingValue = "ldap")
public class LdapIdentityProvider implements IIdentityProvider {

    private final LdapTemplate ldapTemplate;
    private final JwtDecoder jwtDecoder;

    @Override
    public boolean verifyToken(String idToken) {
        try {
            Jwt jwt = jwtDecoder.decode(idToken);
            return jwt.getExpiresAt().isAfter(Instant.now());
        } catch (Exception e) {
            log.error("验证ID Token失败", e);
            return false;
        }
    }

    @Override
    public String extractSubject(String idToken) {
        try {
            Jwt jwt = jwtDecoder.decode(idToken);
            return jwt.getSubject();
        } catch (Exception e) {
            throw new RuntimeException("提取Subject失败", e);
        }
    }

    @Override
    public Applicant getApplicantInfo(String userId) {
        try {
            List<String> dnParts = ldapTemplate.search(
                query()
                    .base(ldapProperties.getUserSearchBase())
                    .filter(ldapProperties.getUserSearchFilter(), userId)
                    .attributes("cn", "mail", "mobile"),
                (Attributes attrs) -> {
                    return String.valueOf(attrs.get("cn").get());
                }
            );
            if (dnParts.isEmpty()) {
                throw new RuntimeException("用户不存在: " + userId);
            }
            return new Applicant(userId, dnParts.get(0));
        } catch (Exception e) {
            throw new RuntimeException("查询用户信息失败", e);
        }
    }
}
```

**依赖任务**: 无
**预计工时**: 16小时
**验收标准**:
- [ ] 支持LDAP认证
- [ ] 支持OAuth2认证
- [ ] 正确解析JWT token
- [ ] 查询用户信息
- [ ] 异常处理完善

---

### 2.3 证书签名 - Bouncy Castle完整实现 [P0]

**任务ID**: SIMPL-003
**文件**: `hybird-domain/src/main/java/org/wyman/domain/signing/model/aggregate/CertificateAuthority.java`
**当前状态**: 简化实现，未生成标准X.509证书

**实现方案**:
1. 使用Bouncy Castle生成标准X.509证书
2. 支持SM2签名算法
3. 支持RSA签名算法
4. 支持ECDSA签名算法
5. 支持ML-DSA后量子签名算法
6. 支持混合签名（双签名）

**实现代码**:
```java
private String generatePemEncoded(Certificate cert, byte[] signature) {
    try {
        // 创建X.509证书生成器
        X509v3CertificateBuilder certBuilder = new JcaX509v3CertificateBuilder(
            new X500Name(caCertificate.getIssuerDN()),
            new BigInteger(cert.getSerialNumber(), 16),
            Date.from(cert.getNotBefore().atZone(ZoneId.systemDefault()).toInstant()),
            Date.from(cert.getNotAfter().atZone(ZoneId.systemDefault()).toInstant()),
            new X500Name(cert.getSubjectDN()),
            cert.getPublicKey()
        );

        // 添加基本扩展
        certBuilder.addExtension(Extension.basicConstraints, true, new BasicConstraints(false));
        certBuilder.addExtension(
            Extension.keyUsage,
            true,
            new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyEncipherment)
        );

        // 添加CRL分发点
        DistributionPointName dpn = new DistributionPointName(
            new GeneralNames(new GeneralName(GeneralName.uniformResourceIdentifier,
                cert.getCrlDistributionPoint()))
        );
        certBuilder.addExtension(
            Extension.cRLDistributionPoints,
            false,
            new CRLDistPoint(new DistributionPoint[]{new DistributionPoint(dpn, null, null)})
        );

        // 添加密钥用途
        if (cert.getSignatureAlgorithm().equals("SM2")) {
            // SM2密钥用途
            certBuilder.addExtension(Extension.extendedKeyUsage, false,
                new ExtendedKeyUsage(new KeyPurposeId[]{
                    KeyPurposeId.id_kp_serverAuth,
                    KeyPurposeId.id_kp_clientAuth
                }));
        }

        // 签名
        ContentSigner signer = new JcaContentSignerBuilder(
            cert.getSignatureAlgorithm().equals("SM2") ? "SM3withSM2" :
            cert.getSignatureAlgorithm().equals("ML-DSA") ? "ML-DSA" :
            cert.getSignatureAlgorithm()
        )
            .setProvider(BouncyCastleProvider.PROVIDER_NAME)
            .build(privateKey);

        X509CertificateHolder certHolder = certBuilder.build(signer);

        // 转换为PEM格式
        PemObject pemObject = new PemObject("CERTIFICATE", certHolder.getEncoded());
        StringWriter writer = new StringWriter();
        JcaPEMWriter pemWriter = new JcaPEMWriter(writer);
        pemWriter.writeObject(pemObject);
        pemWriter.flush();

        return writer.toString();
    } catch (Exception e) {
        throw new RuntimeException("生成X.509证书失败", e);
    }
}
```

**依赖任务**: 无
**预计工时**: 24小时
**验收标准**:
- [ ] 生成有效的X.509证书
- [ ] 证书包含正确的扩展
- [ ] 支持SM2签名
- [ ] 支持RSA签名
- [ ] 支持ECDSA签名
- [ ] 支持ML-DSA签名
- [ ] 支持混合签名

---

### 2.4 混合证书实现 [P0]

**任务ID**: SIMPL-004
**文件**: `hybird-trigger/src/main/java/org/wyman/trigger/http/CertificateController.java:143`
**当前状态**: 直接复用普通证书申请

**实现方案**:
1. 接收传统CSR和后量子CSR
2. 提取两个公钥
3. 使用传统算法签名（SM2/RSA/ECDSA）
4. 使用后量子算法签名（ML-DSA）
5. 合并两个签名到证书中
6. 生成混合证书

**实现代码**:
```java
@PostMapping("/apply/hybrid")
public Response<CertificateIssuanceResponse> applyHybridCertificate(
    @RequestBody HybridCertificateApplyRequest request) {
    try {
        // 1. 创建申请者
        Applicant applicant = new Applicant(
            request.getApplicantId(),
            request.getApplicantName()
        );
        applicant.setEmail(request.getApplicantEmail());

        // 2. 解析传统CSR
        CertificateSigningRequest classicalCSR = csrParser.parseCSR(
            request.getClassicalCsrPemData()
        );

        // 3. 解析后量子CSR
        CertificateSigningRequest pqCSR = csrParser.parseCSR(
            request.getPqCsrPemData()
        );

        // 4. 执行身份验证
        AuthenticationRequest authRequest = authenticationService.processAuthentication(
            UUID.randomUUID().toString(),
            request.getApplicantId(),
            request.getIdToken(),
            request.getClassicalCsrPemData()
        );

        if (authRequest.getStatus() != AuthRequestStatus.VALIDATION_SUCCESSFUL) {
            return Response.fail("身份验证失败: " + authRequest.getFailureReason());
        }

        // 5. 获取策略
        CertificateType certType = CertificateType.HYBRID;
        var policy = policyService.getPolicyForCertificateType(certType);
        if (policy == null) {
            return Response.fail("未找到可用的混合证书策略");
        }

        // 6. 验证两个CSR
        if (!policyService.validateCSRAgainstPolicy(
            certType,
            "SM2",
            "ML-KEM",
            classicalCSR.getSubjectDN(),
            LocalDateTime.now(),
            request.getNotAfter()
        )) {
            return Response.fail("CSR不符合策略要求");
        }

        // 7. 签发混合证书
        Certificate hybridCert = signingService.issueHybridCertificate(
            request.getCaName(),
            classicalCSR.getSubjectDN(),
            classicalCSR.getPublicKey(),
            pqCSR.getPublicKey(),
            LocalDateTime.now(),
            request.getNotAfter(),
            "SM2",
            "ML-DSA",
            null
        );

        // 8. 保存证书
        Certificate certificate = new Certificate(
            hybridCert.getSerialNumber(),
            certType,
            hybridCert.getSubjectDN(),
            hybridCert.getIssuerDN(),
            hybridCert.getNotBefore(),
            hybridCert.getNotAfter(),
            request.getApplicantId()
        );
        certificate.setPemEncoded(hybridCert.getPemEncoded());
        certificate.setIssuanceRequestId(authRequest.getRequestId());
        certificate.activate();

        lifecycleService.saveCertificate(certificate);

        // 9. 构建响应
        CertificateIssuanceResponse response = new CertificateIssuanceResponse();
        response.setSerialNumber(hybridCert.getSerialNumber());
        response.setCertificatePem(hybridCert.getPemEncoded());
        response.setSubjectDN(hybridCert.getSubjectDN());
        response.setIssuerDN(hybridCert.getIssuerDN());
        response.setNotBefore(hybridCert.getNotBefore().toString());
        response.setNotAfter(hybridCert.getNotAfter().toString());
        response.setSignatureAlgorithm(hybridCert.getSignatureAlgorithm());

        return Response.success(response);
    } catch (Exception e) {
        log.error("申请混合证书失败", e);
        return Response.fail(e.getMessage());
    }
}
```

**依赖任务**: SIMPL-003, SIMPL-005
**预计工时**: 16小时
**验收标准**:
- [ ] 支持混合证书申请
- [ ] 验证两个CSR
- [ ] 生成双签名证书
- [ ] 证书包含传统签名
- [ ] 证书包含后量子签名

---

### 2.5 公钥提取 - 从CSR中提取公钥 [P0] ✅ 已完成

**状态**: 已完成 (2026-01-07)

**任务ID**: SIMPL-005
**文件**: `hybird-trigger/src/main/java/org/wyman/trigger/http/CertificateController.java:96`
**当前状态**: 传入null，未从CSR提取公钥

**实现方案**:
1. 实现CSR解析器
2. 提取公钥对象
3. 传递给签名服务

**实现代码**:
```java
public class BouncyCastleCSRParser implements ICSRParser {

    @Override
    public CertificateSigningRequest parseCSR(String csrPemData) {
        try {
            // 读取PEM格式的CSR
            PEMParser pemParser = new PEMParser(
                new StringReader(csrPemData)
            );
            PKCS10CertificationRequest csr = (PKCS10CertificationRequest)
                pemParser.readObject();

            CertificateSigningRequest csrData = new CertificateSigningRequest();
            csrData.setCsrData(csrPemData);
            csrData.setSubjectDN(csr.getSubject().toString());
            csrData.setPublicKey(csr.getPublicKey());

            // 提取公钥算法
            String keyAlgorithm = csr.getPublicKey().getAlgorithm();
            csrData.setPublicKeyAlgorithm(keyAlgorithm);

            // 提取签名算法
            String sigAlgorithm = csr.getSignatureAlgorithm().getAlgorithm().getName();
            csrData.setSignatureAlgorithm(sigAlgorithm);

            return csrData;
        } catch (Exception e) {
            throw new RuntimeException("解析CSR失败", e);
        }
    }
}
```

**使用示例**:
```java
// 在Controller中
CertificateSigningRequest csr = csrParser.parseCSR(request.getCsrPemData());
org.wyman.domain.signing.valobj.Certificate cert = signingService.issueCertificate(
    request.getCaName(),
    csr.getSubjectDN(),
    csr.getPublicKey(),  // 从CSR中提取的公钥
    LocalDateTime.now(),
    request.getNotAfter(),
    "SM2",
    null
);
```

**依赖任务**: 无
**预计工时**: 8小时
**验收标准**:
- [ ] 正确解析CSR PEM格式
- [ ] 提取公钥对象
- [ ] 提取主题DN
- [ ] 提取签名算法
- [ ] 异常处理完善

---

### 2.6 审计日志分页 - 数据库分页 [P2]

**任务ID**: SIMPL-006
**文件**: `hybird-domain/src/main/java/org/wyman/domain/audit/service/AuditService.java:218`
**当前状态**: 内存分页，查询全部记录

**实现方案**:
1. 在Mapper中添加分页查询方法
2. 使用MyBatis的RowBounds或PageHelper
3. 支持条件查询+分页

**Mapper代码**:
```xml
<select id="findByConditionWithPagination" resultMap="AuditLogMap">
    SELECT * FROM audit_log
    <where>
        <if test="eventType != null and eventType != ''">
            AND event_type = #{eventType}
        </if>
        <if test="operator != null and operator != ''">
            AND operator = #{operator}
        </if>
        <if test="startTime != null">
            AND timestamp >= #{startTime}
        </if>
        <if test="endTime != null">
            AND timestamp <= #{endTime}
        </if>
    </where>
    ORDER BY timestamp DESC
    LIMIT #{offset}, #{limit}
</select>
```

**Repository代码**:
```java
@Override
public List<AuditEvent> findByConditionWithPagination(String eventType,
                                                     String operator,
                                                     LocalDateTime startTime,
                                                     LocalDateTime endTime,
                                                     int offset,
                                                     int limit) {
    AuditLogQuery query = new AuditLogQuery();
    query.setEventType(eventType);
    query.setOperator(operator);
    query.setStartTime(startTime);
    query.setEndTime(endTime);
    query.setOffset(offset);
    query.setLimit(limit);

    return auditLogDao.findByConditionWithPagination(query)
        .stream()
        .map(this::toDomain)
        .collect(Collectors.toList());
}
```

**Service代码**:
```java
public List<AuditEvent> queryAuditEvents(String operator,
                                         String operationType,
                                         LocalDateTime startTime,
                                         LocalDateTime endTime,
                                         Integer pageSize,
                                         Integer pageNumber) {
    // 使用数据库分页查询
    int offset = (pageNumber - 1) * pageSize;
    return auditEventRepository.findByConditionWithPagination(
        operationType,
        operator,
        startTime,
        endTime,
        offset,
        pageSize
    );
}
```

**依赖任务**: 无
**预计工时**: 4小时
**验收标准**:
- [ ] 使用数据库分页
- [ ] 支持多条件查询
- [ ] 按时间倒序排列
- [ ] 性能优化

---

### 2.7 证书链构建 - 完整实现 [P2]

**任务ID**: SIMPL-007
**文件**: `hybird-domain/src/main/java/org/wyman/domain/chain/service/CertificateChainService.java:104`
**当前状态**: 简化实现，只查找一层

**实现方案**:
1. 使用AuthorityKeyIdentifier和SubjectKeyIdentifier构建
2. 支持多级CA层次
3. 支持交叉证书

**实现代码**:
```java
public List<CertificateChainInfo> getCertificateChain(String serialNumber) {
    List<CertificateChainInfo> chain = new ArrayList<>();

    Certificate certificate = certificateRepository.findBySerialNumber(serialNumber);
    if (certificate == null) {
        return chain;
    }

    // 添加当前证书
    chain.add(new CertificateChainInfo(
        certificate.getSerialNumber(),
        certificate.getSubjectDN(),
        certificate.getIssuerDN(),
        certificate.getPemEncoded(),
        0
    ));

    // 递归查找父证书
    buildCertificateChain(certificate, chain, 1);

    return chain;
}

private void buildCertificateChain(Certificate cert,
                                  List<CertificateChainInfo> chain,
                                  int level) {
    // 如果是自签名证书，停止查找
    if (cert.getSubjectDN().equals(cert.getIssuerDN())) {
        return;
    }

    // 查找父证书（颁发者）
    List<Certificate> possibleIssuers = certificateRepository.findByStatus(
        CertificateStatus.ACTIVE
    ).stream()
        .filter(c -> c.getSubjectDN().equals(cert.getIssuerDN()))
        .toList();

    for (Certificate issuer : possibleIssuers) {
        // 验证颁发者是否正确（通过证书扩展）
        if (isIssuerValid(cert, issuer)) {
            chain.add(new CertificateChainInfo(
                issuer.getSerialNumber(),
                issuer.getSubjectDN(),
                issuer.getIssuerDN(),
                issuer.getPemEncoded(),
                level
            ));

            // 继续向上查找
            buildCertificateChain(issuer, chain, level + 1);
            break;
        }
    }
}

private boolean isIssuerValid(Certificate cert, Certificate issuer) {
    // 通过AuthorityKeyIdentifier和SubjectKeyIdentifier验证
    // 这里简化实现，实际需要解析证书扩展
    return issuer.getSubjectDN().equals(cert.getIssuerDN());
}
```

**依赖任务**: 无
**预计工时**: 8小时
**验收标准**:
- [ ] 正确构建完整证书链
- [ ] 支持多级CA
- [ ] 验证颁发关系
- [ ] 包含根CA和中间CA

---

### 2.8 CA状态管理 - 完整实现 [P2]

**任务ID**: SIMPL-008
**文件**: `hybird-domain/src/main/java/org/wyman/domain/signing/service/SigningService.java:129,141`
**当前状态**: 空实现，未管理CA状态

**实现方案**:
1. 为CA添加状态字段（ENABLED/DISABLED/REVOKED）
2. 实现CA状态转换逻辑
3. 添加CA状态验证

**实现代码**:
```java
// CertificateAuthority添加状态字段
public class CertificateAuthority {
    private String caId;
    private String caName;
    private Certificate caCertificate;
    private CAStatus status;  // 新增字段
    private String revocationReason;
    private LocalDateTime revocationTime;
    // ...
}

// CA状态枚举
public enum CAStatus {
    ENABLED,
    DISABLED,
    REVOKED
}

// 激活CA
public void activateCertificateAuthority(String caId, boolean active) {
    CertificateAuthority ca = caRepository.findById(caId);
    if (ca == null) {
        throw new RuntimeException("CA不存在: " + caId);
    }

    if (active) {
        ca.setStatus(CAStatus.ENABLED);
        log.info("CA已激活: caId={}", caId);
    } else {
        ca.setStatus(CAStatus.DISABLED);
        log.info("CA已停用: caId={}", caId);
    }

    caRepository.save(ca);
}

// 吊销CA
public void revokeCertificateAuthority(String caId, String reason) {
    CertificateAuthority ca = caRepository.findById(caId);
    if (ca == null) {
        throw new RuntimeException("CA不存在: " + caId);
    }

    if (ca.getStatus() == CAStatus.REVOKED) {
        throw new RuntimeException("CA已被吊销");
    }

    ca.setStatus(CAStatus.REVOKED);
    ca.setRevocationReason(reason);
    ca.setRevocationTime(LocalDateTime.now());

    caRepository.save(ca);
    log.info("CA已吊销: caId={}, reason={}", caId, reason);
}

// 签发证书时验证CA状态
public Certificate issueCertificate(String caName, ...) {
    CertificateAuthority ca = caRepository.findByName(caName);
    if (ca == null) {
        throw new RuntimeException("CA不存在: " + caName);
    }

    if (ca.getStatus() != CAStatus.ENABLED) {
        throw new RuntimeException("CA未启用或已被吊销: " + caName);
    }

    // ... 签发逻辑
}
```

**依赖任务**: 无
**预计工时**: 4小时
**验收标准**:
- [ ] 支持CA激活/停用
- [ ] 支持CA吊销
- [ ] 验证CA状态
- [ ] 记录状态变更审计日志

---

### 2.9 CSR策略验证 - 完整实现 [P1]

**任务ID**: SIMPL-009
**文件**: `hybird-domain/src/main/java/org/wyman/domain/policy/service/PolicyService.java:190`
**当前状态**: 只检查策略是否启用

**实现方案**:
1. 解析CSR中的主题DN
2. 验证签名算法
3. 验证密钥长度
4. 验证有效期

**实现代码**:
```java
public boolean validateCSR(String policyId, String csrPemData) {
    CertificatePolicy policy = policyRepository.findById(policyId);
    if (policy == null) {
        throw new RuntimeException("策略不存在: " + policyId);
    }

    if (!policy.isEnabled()) {
        return false;
    }

    // 解析CSR
    CertificateSigningRequest csr = csrParser.parseCSR(csrPemData);

    // 验证密码学参数
    if (!policy.validateCryptographicParameters(
        csr.getSignatureAlgorithm(),
        csr.getKeyEncapsulationAlgorithm()
    )) {
        log.warn("CSR密码学参数不符合策略: sigAlg={}, kemAlg={}",
            csr.getSignatureAlgorithm(),
            csr.getKeyEncapsulationAlgorithm());
        return false;
    }

    // 验证主题DN
    if (!policy.validateSubjectDN(csr.getSubjectDN())) {
        log.warn("CSR主题DN不符合策略: subjectDN={}", csr.getSubjectDN());
        return false;
    }

    // 验证密钥长度
    if (policy.getCryptographicRule().getMinKeyLength() != null) {
        int keyLength = getKeyLength(csr.getPublicKey());
        if (keyLength < policy.getCryptographicRule().getMinKeyLength()) {
            log.warn("CSR密钥长度不符合策略: keyLength={}, min={}",
                keyLength, policy.getCryptographicRule().getMinKeyLength());
            return false;
        }
    }

    return true;
}

private int getKeyLength(PublicKey publicKey) {
    if (publicKey instanceof RSAPublicKey) {
        return ((RSAPublicKey) publicKey).getModulus().bitLength();
    } else if (publicKey instanceof ECPublicKey) {
        return ((ECPublicKey) publicKey).getParams().getCurve().getField().getFieldSize();
    } else if (publicKey.getAlgorithm().equals("SM2")) {
        return 256;
    }
    return 0;
}
```

**依赖任务**: SIMPL-005
**预计工时**: 8小时
**验收标准**:
- [ ] 解析CSR完整信息
- [ ] 验证签名算法
- [ ] 验证密钥长度
- [ ] 验证主题DN
- [ ] 记录验证失败原因

---

### 2.10 审计日志资源查询 - 完整实现 [P2]

**任务ID**: SIMPL-010
**文件**: `hybird-domain/src/main/java/org/wyman/domain/audit/service/AuditService.java:234`
**当前状态**: 简化为时间范围查询

**实现方案**:
1. 在Mapper中添加按资源查询方法
2. 支持资源类型和资源ID过滤

**Mapper代码**:
```xml
<select id="findByResource" resultMap="AuditLogMap">
    SELECT * FROM audit_log
    WHERE target_resource LIKE CONCAT(#{resourceType}, ':', #{resourceId})
    ORDER BY timestamp DESC
</select>
```

**Repository代码**:
```java
@Override
public List<AuditEvent> findByResource(String resourceType, String resourceId) {
    List<AuditLogPO> poList = auditLogDao.findByResource(resourceType, resourceId);
    return poList.stream()
        .map(this::toDomain)
        .collect(Collectors.toList());
}
```

**Service代码**:
```java
public List<AuditEvent> queryAuditEventsByResource(String resourceType, String resourceId) {
    return auditEventRepository.findByResource(resourceType, resourceId);
}
```

**依赖任务**: 无
**预计工时**: 2小时
**验收标准**:
- [ ] 按资源类型查询
- [ ] 按资源ID查询
- [ ] 按时间倒序排列

---

## 三、配置优化任务

### 3.1 启用Redis缓存 [P2]

**任务ID**: CONF-001
**文件**: `hybird-app/src/main/resources/application-dev.yml`
**当前状态**: Redis配置被注释

**实现方案**:
1. 取消Redis配置注释
2. 配置连接参数
3. 配置序列化
4. 配置缓存策略

**配置代码**:
```yaml
spring:
  data:
    redis:
      host: 49.233.215.82
      port: 6379
      password: wyman1112
      database: 0
      timeout: 5000ms
      lettuce:
        pool:
          max-active: 10
          max-idle: 10
          min-idle: 5
          max-wait: 3000ms

# Redis缓存配置
redis:
  cache:
    ttl: 86400  # 默认过期时间（秒）
    key-prefix: hybird:
    cache-names:
      - revocation:cache  # 吊销状态缓存
      - policy:*         # 策略缓存
```

**Redis配置类**:
```java
@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);

        // 使用Jackson2JsonRedisSerializer序列化value
        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper mapper = new ObjectMapper();
        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance,
            ObjectMapper.DefaultTyping.NON_FINAL);
        serializer.setObjectMapper(mapper);

        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(serializer);
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(serializer);
        template.afterPropertiesSet();
        return template;
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(24))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new Jackson2JsonRedisSerializer<>(Object.class)))
            .disableCachingNullValues();

        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
    }
}
```

**依赖任务**: 无
**预计工时**: 2小时
**验收标准**:
- [ ] Redis连接正常
- [ ] 缓存读写正常
- [ ] 支持序列化
- [ ] 支持过期时间
- [ ] 缓存降级机制

---

## 四、功能增强任务

### 4.1 证书自动续期 [P2]

**任务ID**: FEAT-001
**描述**: 支持证书到期前自动续期

**实现方案**:
1. 添加自动续期配置
2. 实现自动续期定时任务
3. 生成新证书
4. 更新证书状态

**配置**:
```yaml
certificate:
  auto-renewal:
    enabled: true
    days-before-expiry: 30
    renewal-validity-days: 365
```

**定时任务**:
```java
@Scheduled(cron = "0 0 8 * * ?")
public void autoRenewExpiringCertificates() {
    log.info("开始自动续期证书");

    LocalDateTime expiryThreshold = LocalDateTime.now().plusDays(autoRenewalDays);
    List<Certificate> expiringCerts = lifecycleService
        .getCertificatesExpiringBefore(expiryThreshold);

    for (Certificate oldCert : expiringCerts) {
        try {
            // 标记旧证书
            lifecycleService.markCertificateForRenewal(oldCert.getSerialNumber());

            // 生成新CSR（需要申请者配合）
            // 这里简化实现，实际需要申请者提交新CSR

            log.info("证书已标记为待续期: serialNumber={}", oldCert.getSerialNumber());
        } catch (Exception e) {
            log.error("自动续期证书失败: serialNumber={}", oldCert.getSerialNumber(), e);
        }
    }

    log.info("自动续期完成: count={}", expiringCerts.size());
}
```

**依赖任务**: 无
**预计工时**: 16小时
**验收标准**:
- [ ] 自动扫描临期证书
- [ ] 标记证书为待续期
- [ ] 发送续期通知
- [ ] 记录审计日志

---

### 4.2 OCSP在线证书状态协议 [P2]

**任务ID**: FEAT-002
**描述**: 实现OCSP协议，提供实时证书状态查询

**实现方案**:
1. 实现OCSP请求解析
2. 实现OCSP响应生成
3. 提供OCSP HTTP接口
4. 支持OCSP签名

**依赖添加**:
```xml
<dependency>
    <groupId>org.bouncycastle</groupId>
    <artifactId>bcprov-jdk18on</artifactId>
    <version>1.78.1</version>
</dependency>
<dependency>
    <groupId>org.bouncycastle</groupId>
    <artifactId>bcpkix-jdk18on</artifactId>
    <version>1.78.1</version>
</dependency>
```

**OCSP Controller**:
```java
@RestController
@RequestMapping("/ocsp")
public class OCSPController {

    @PostMapping
    public byte[] handleOCSPRequest(@RequestBody byte[] requestBytes) {
        try {
            // 解析OCSP请求
            OCSPReq request = new OCSPReq(requestBytes);

            // 构建OCSP响应
            OCSPRespBuilder builder = new OCSPRespBuilder();

            for (Req req : request.getRequestList()) {
                CertificateID certID = req.getCertID();

                // 查询证书状态
                boolean revoked = revocationStatusService.checkRevocationStatus(
                    certID.getSerialNumber().toString()
                );

                if (revoked) {
                    RevokedDetail detail = revocationStatusService
                        .getRevocationDetail(certID.getSerialNumber().toString());

                    builder.addResponse(certID,
                        org.bouncycastle.cert.ocsp.CertificateStatus.REVOKED,
                        new Date(),
                        detail.getRevocationReason().ordinal(),
                        new Date());
                } else {
                    builder.addResponse(certID,
                        org.bouncycastle.cert.ocsp.CertificateStatus.GOOD,
                        new Date());
                }
            }

            // 签名响应
            OCSPResp response = builder.build(
                caPrivateKey,
                digestOID,
                new Certificate[]{caCertificate},
                new Date()
            );

            return response.getEncoded();
        } catch (Exception e) {
            log.error("处理OCSP请求失败", e);
            return new OCSPResp(OCSPResp.INTERNAL_ERROR, new Date()).getEncoded();
        }
    }
}
```

**依赖任务**: 无
**预计工时**: 24小时
**验收标准**:
- [ ] 解析OCSP请求
- [ ] 查询证书状态
- [ ] 生成OCSP响应
- [ ] 支持签名
- [ ] 符合RFC 6960标准

---

### 4.3 HSM硬件安全模块集成 [P1]

**任务ID**: FEAT-003
**描述**: 集成HSM，保护CA私钥安全

**实现方案**:
1. 选择HSM提供商（Thales/Utimaco/国产HSM）
2. 实现HSM私钥提供者
3. 支持密钥导入/导出
4. 支持签名操作

**HSM私钥提供者**:
```java
@Component
@ConditionalOnProperty(name = "security.hsm.enabled", havingValue = "true")
public class HSMPrivateKeyProvider implements IPrivateKeyProvider {

    private final PKCS11Provider pkcs11Provider;
    private final KeyStore hsmKeyStore;
    private final char[] pin;

    public HSMPrivateKeyProvider(HSMConfig config) {
        try {
            // 加载PKCS#11驱动
            this.pkcs11Provider = new PKCS11Provider(config.getLibraryPath());
            Security.addProvider(pkcs11Provider);

            // 初始化HSM KeyStore
            this.hsmKeyStore = KeyStore.getInstance("PKCS11", pkcs11Provider);
            this.pin = config.getPin().toCharArray();
            hsmKeyStore.load(null, pin);
        } catch (Exception e) {
            throw new RuntimeException("初始化HSM失败", e);
        }
    }

    @Override
    public PrivateKey getSigningPrivateKey(String algorithm) {
        try {
            String alias = getAliasForAlgorithm(algorithm);
            PrivateKey key = (PrivateKey) hsmKeyStore.getKey(alias, pin);
            if (key == null) {
                throw new RuntimeException("HSM中未找到私钥: " + alias);
            }
            return key;
        } catch (Exception e) {
            throw new RuntimeException("从HSM获取私钥失败", e);
        }
    }

    private String getAliasForAlgorithm(String algorithm) {
        switch (algorithm) {
            case "SM2":
                return "ca-sm2-private";
            case "RSA":
                return "ca-rsa-private";
            default:
                throw new RuntimeException("不支持的算法: " + algorithm);
        }
    }

    @Override
    public KeyPair generateKeyPair(String algorithm, int keySize) {
        try {
            KeyPairGenerator generator = KeyPairGenerator.getInstance(
                algorithm, pkcs11Provider);
            generator.initialize(keySize);
            return generator.generateKeyPair();
        } catch (Exception e) {
            throw new RuntimeException("在HSM中生成密钥对失败", e);
        }
    }
}
```

**配置**:
```yaml
security:
  hsm:
    enabled: false
    library-path: /usr/lib/libpkcs11.so
    slot: 0
    pin: "123456"
```

**依赖任务**: 无
**预计工时**: 32小时
**验收标准**:
- [ ] 成功连接HSM
- [ ] 从HSM读取私钥
- [ ] 使用HSM签名
- [ ] 密钥不出HSM

---

### 4.4 多租户支持 [P3]

**任务ID**: FEAT-004
**描述**: 支持多租户，为不同租户隔离数据和策略

**实现方案**:
1. 添加租户ID字段
2. 实现租户拦截器
3. 实现租户数据隔离
4. 支持租户级策略

**租户实体**:
```java
@Entity
@Table(name = "tenant")
public class Tenant {
    @Id
    private String tenantId;
    private String tenantName;
    private String status;
    private LocalDateTime createTime;
}
```

**租户拦截器**:
```java
@Component
public class TenantInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request,
                           HttpServletResponse response,
                           Object handler) {
        String tenantId = request.getHeader("X-Tenant-ID");
        if (tenantId != null) {
            TenantContext.setTenantId(tenantId);
        }
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request,
                              HttpServletResponse response,
                              Object handler,
                              Exception ex) {
        TenantContext.clear();
    }
}
```

**租户上下文**:
```java
public class TenantContext {
    private static final ThreadLocal<String> TENANT_ID = new ThreadLocal<>();

    public static void setTenantId(String tenantId) {
        TENANT_ID.set(tenantId);
    }

    public static String getTenantId() {
        return TENANT_ID.get();
    }

    public static void clear() {
        TENANT_ID.remove();
    }
}
```

**依赖任务**: 无
**预计工时**: 40小时
**验收标准**:
- [ ] 数据隔离
- [ ] 策略隔离
- [ ] CA隔离
- [ ] 审计日志隔离

---

## 五、性能优化任务

### 5.1 数据库索引优化 [P2]

**任务ID**: PERF-001
**描述**: 为数据库表添加合适的索引

**实现方案**:
1. 分析查询频率
2. 添加复合索引
3. 优化索引策略

**索引SQL**:
```sql
-- 证书表索引
CREATE INDEX idx_certificate_serial ON certificate(serial_number);
CREATE INDEX idx_certificate_status ON certificate(status);
CREATE INDEX idx_certificate_applicant ON certificate(applicant_id);
CREATE INDEX idx_certificate_expiry ON certificate(not_after);
CREATE INDEX idx_certificate_status_expiry ON certificate(status, not_after);

-- 审计日志表索引
CREATE INDEX idx_audit_log_event_type ON audit_log(event_type);
CREATE INDEX idx_audit_log_operator ON audit_log(operator);
CREATE INDEX idx_audit_log_timestamp ON audit_log(timestamp);
CREATE INDEX idx_audit_log_resource ON audit_log(target_resource);
CREATE INDEX idx_audit_log_time_type ON audit_log(timestamp, event_type);

-- CA表索引
CREATE INDEX idx_ca_name ON certificate_authority(ca_name);
CREATE INDEX idx_ca_status ON certificate_authority(enabled);

-- 策略表索引
CREATE INDEX idx_policy_type ON certificate_policy(certificate_type);
CREATE INDEX idx_policy_enabled ON certificate_policy(enabled);

-- 吊销状态缓存表索引
CREATE INDEX idx_cache_key ON revocation_status_cache(cache_key);
```

**依赖任务**: 无
**预计工时**: 2小时
**验收标准**:
- [ ] 查询性能提升
- [ ] 索引合理
- [ ] 无冗余索引

---

### 5.2 批量操作优化 [P2]

**任务ID**: PERF-002
**描述**: 优化批量查询和批量插入

**实现方案**:
1. 使用MyBatis批量插入
2. 使用IN查询替代循环查询
3. 使用批量更新

**批量插入**:
```xml
<insert id="batchInsert" parameterType="list">
    INSERT INTO audit_log (log_id, event_type, payload, operator, timestamp)
    VALUES
    <foreach collection="list" item="item" separator=",">
        (#{item.logId}, #{item.eventType}, #{item.payload},
         #{item.operator}, #{item.timestamp})
    </foreach>
</insert>
```

**IN查询**:
```xml
<select id="findBySerialNumbers" resultMap="CertificateMap">
    SELECT * FROM certificate
    WHERE serial_number IN
    <foreach collection="serialNumbers" item="sn" open="(" separator="," close=")">
        #{sn}
    </foreach>
</select>
```

**依赖任务**: 无
**预计工时**: 4小时
**验收标准**:
- [ ] 批量插入性能提升
- [ ] 批量查询性能提升
- [ ] 减少数据库连接数

---

### 5.3 缓存预热 [P2]

**任务ID**: PERF-003
**描述**: 系统启动时预热缓存

**实现方案**:
1. 实现缓存预热接口
2. 启动时加载热点数据
3. 定时刷新缓存

**缓存预热**:
```java
@Component
public class CacheWarmupService implements ApplicationRunner {

    @Autowired
    private RevocationStatusService revocationStatusService;

    @Autowired
    private PolicyService policyService;

    @Override
    public void run(ApplicationArguments args) {
        log.info("开始缓存预热");

        try {
            // 预热吊销状态缓存
            revocationStatusService.warmupCache();
            log.info("吊销状态缓存预热完成");

            // 预热策略缓存
            List<CertificatePolicy> policies = policyService.getAllPolicies();
            for (CertificatePolicy policy : policies) {
                policyService.cachePolicy(policy.getPolicyId());
            }
            log.info("策略缓存预热完成: count={}", policies.size());
        } catch (Exception e) {
            log.error("缓存预热失败", e);
        }
    }
}
```

**依赖任务**: CONF-001
**预计工时**: 4小时
**验收标准**:
- [ ] 启动时自动预热
- [ ] 缓存命中率提升
- [ ] 冷启动性能优化

---

## 六、安全增强任务

### 6.1 HTTPS/TLS配置 [P1]

**任务ID**: SEC-001
**描述**: 启用HTTPS加密传输

**实现方案**:
1. 配置SSL证书
2. 强制HTTPS
3. 配置TLS协议版本

**配置**:
```yaml
server:
  port: 8443
  ssl:
    enabled: true
    key-store: classpath:keystore.p12
    key-store-password: changeit
    key-store-type: PKCS12
    key-alias: server
    protocol: TLS
    enabled-protocols:
      - TLSv1.2
      - TLSv1.3
    ciphers:
      - TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
      - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
      - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
      - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256

# 强制HTTPS
security:
  require-ssl: true
```

**HTTP到HTTPS重定向**:
```java
@Configuration
public class HttpsRedirectConfig {

    @Bean
    public ServletWebServerFactory servletContainer() {
        TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory();
        tomcat.addAdditionalTomcatConnectors(createStandardConnector());
        return tomcat;
    }

    private Connector createStandardConnector() {
        Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol");
        connector.setPort(8080);
        connector.setSecure(false);
        connector.setScheme("http");
        return connector;
    }
}
```

**依赖任务**: 无
**预计工时**: 4小时
**验收标准**:
- [ ] HTTPS访问正常
- [ ] SSL证书有效
- [ ] HTTP自动重定向到HTTPS
- [ ] TLS协议版本正确

---

### 6.2 API权限控制 [P1]

**任务ID**: SEC-002
**描述**: 实现基于角色的API访问控制

**实现方案**:
1. 实现Spring Security
2. 配置角色和权限
3. 实现JWT认证
4. 实现API鉴权

**Spring Security配置**:
```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/certificate/apply").permitAll()
                .requestMatchers("/api/authentication/**").permitAll()
                .requestMatchers("/api/certificate/**").hasAnyRole("USER", "CERT_ADMIN", "SYS_ADMIN")
                .requestMatchers("/api/policy/**").hasAnyRole("CERT_ADMIN", "SYS_ADMIN")
                .requestMatchers("/api/ca/**").hasRole("SYS_ADMIN")
                .requestMatchers("/api/audit/**").hasAnyRole("AUDITOR", "SYS_ADMIN")
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthenticationFilter,
                UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

**JWT过滤器**:
```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Autowired
    private JwtTokenProvider jwtTokenProvider;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                   HttpServletResponse response,
                                   FilterChain filterChain) {
        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt) && jwtTokenProvider.validateToken(jwt)) {
                String username = jwtTokenProvider.getUsernameFromJWT(jwt);
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(userDetails, null,
                        userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource()
                    .buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            log.error("JWT认证失败", ex);
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

**依赖任务**: 无
**预计工时**: 16小时
**验收标准**:
- [ ] JWT认证正常
- [ ] 角色权限控制正确
- [ ] 未授权请求被拦截
- [ ] Token过期自动失效

---

### 6.3 敏感数据加密 [P1]

**任务ID**: SEC-003
**描述**: 加密存储敏感信息（私钥、证书）

**实现方案**:
1. 实现数据加密服务
2. 配置加密密钥
3. 加密敏感字段
4. 解密读取

**加密服务**:
```java
@Service
public class EncryptionService {

    private final AES aes;

    public EncryptionService(EncryptionConfig config) {
        try {
            SecretKeySpec keySpec = new SecretKeySpec(
                config.getEncryptionKey().getBytes(), "AES");
            this.aes = new AES(keySpec);
        } catch (Exception e) {
            throw new RuntimeException("初始化加密服务失败", e);
        }
    }

    public String encrypt(String plaintext) {
        try {
            return aes.encrypt(plaintext);
        } catch (Exception e) {
            throw new RuntimeException("加密失败", e);
        }
    }

    public String decrypt(String ciphertext) {
        try {
            return aes.decrypt(ciphertext);
        } catch (Exception e) {
            throw new RuntimeException("解密失败", e);
        }
    }
}
```

**使用示例**:
```java
// 保存时加密
String encryptedPEM = encryptionService.encrypt(certPem);
certificate.setPemEncoded(encryptedPEM);

// 读取时解密
String decryptedPEM = encryptionService.decrypt(certificate.getPemEncoded());
```

**配置**:
```yaml
encryption:
  enabled: true
  algorithm: AES-256
  key: "your-256-bit-encryption-key"
```

**依赖任务**: 无
**预计工时**: 8小时
**验收标准**:
- [ ] 私钥加密存储
- [ ] 证书加密存储
- [ ] 加密/解密正确
- [ ] 性能可接受

---

## 七、测试任务

### 7.1 单元测试 [P2]

**任务ID**: TEST-001
**描述**: 为核心业务逻辑编写单元测试

**实现方案**:
1. 使用JUnit 5
2. 使用Mockito模拟依赖
3. 覆盖率目标80%+

**示例测试**:
```java
@SpringBootTest
class CertificateLifecycleServiceTest {

    @Autowired
    private CertificateLifecycleService lifecycleService;

    @MockBean
    private ICertificateRepository repository;

    @Test
    void testRevokeCertificate() {
        // Arrange
        Certificate cert = createTestCertificate();
        when(repository.findBySerialNumber(anyString())).thenReturn(cert);

        // Act
        lifecycleService.revokeCertificate(cert.getSerialNumber(),
            RevocationReason.KEY_COMPROMISE, "admin", "密钥泄露");

        // Assert
        assertEquals(CertificateStatus.REVOKED, cert.getStatus());
        assertNotNull(cert.getRevocationInfo());
        assertEquals(RevocationReason.KEY_COMPROMISE,
            cert.getRevocationInfo().getRevocationReason());
    }
}
```

**依赖任务**: 无
**预计工时**: 40小时
**验收标准**:
- [ ] 覆盖率80%+
- [ ] 测试通过
- [ ] 测试覆盖所有核心功能

---

### 7.2 集成测试 [P2]

**任务ID**: TEST-002
**描述**: 编写集成测试，测试完整流程

**实现方案**:
1. 使用Spring Boot Test
2. 使用TestContainers测试数据库
3. 测试完整业务流程

**示例测试**:
```java
@SpringBootTest
@AutoConfigureMockMvc
@Testcontainers
class CertificateIntegrationTest {

    @Container
    static MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0");

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private CertificateLifecycleService lifecycleService;

    @Test
    void testCertificateIssuanceFlow() throws Exception {
        // 1. 申请证书
        String applyRequest = """
            {
                "applicantId": "user001",
                "applicantName": "测试用户",
                "idToken": "mock-token",
                "csrPemData": "-----BEGIN CERTIFICATE REQUEST-----\\n...",
                "certificateType": "DEVICE_CERT",
                "notAfter": "2026-01-01T00:00:00",
                "caName": "root-ca"
            }
            """;

        MvcResult result = mockMvc.perform(post("/api/certificate/apply")
                .contentType(MediaType.APPLICATION_JSON)
                .content(applyRequest))
            .andExpect(status().isOk())
            .andReturn();

        String response = result.getResponse().getContentAsString();
        assertTrue(response.contains("serialNumber"));

        // 2. 查询证书
        JSONObject json = JSON.parseObject(response);
        String serialNumber = json.getJSONObject("data").getString("serialNumber");

        mockMvc.perform(get("/api/certificate/query")
                .param("serialNumber", serialNumber))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.serialNumber").value(serialNumber));
    }
}
```

**依赖任务**: 无
**预计工时**: 32小时
**验收标准**:
- [ ] 测试完整业务流程
- [ ] 测试通过
- [ ] 使用真实数据库

---

### 7.3 性能测试 [P3]

**任务ID**: TEST-003
**描述**: 使用JMeter进行压力测试

**实现方案**:
1. 设计JMeter测试计划
2. 模拟并发用户
3. 监控性能指标

**测试场景**:
1. 证书申请并发测试（100并发）
2. 证书查询并发测试（1000并发）
3. 批量吊销状态查询测试（10个证书/请求）

**性能目标**:
- 证书申请响应时间 < 500ms
- 证书查询响应时间 < 100ms
- 批量状态查询响应时间 < 200ms
- 支持并发用户数 > 1000

**依赖任务**: 无
**预计工时**: 16小时
**验收标准**:
- [ ] 达到性能目标
- [ ] 无内存泄漏
- [ ] 无数据库连接泄漏

---

## 八、文档完善任务

### 8.1 API文档生成 [P2]

**任务ID**: DOC-001
**描述**: 使用Swagger生成API文档

**实现方案**:
1. 集成SpringDoc OpenAPI
2. 配置API文档
3. 添加API注解

**依赖添加**:
```xml
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.2.0</version>
</dependency>
```

**配置**:
```yaml
springdoc:
  api-docs:
    path: /api-docs
  swagger-ui:
    path: /swagger-ui.html
  packages-to-scan: org.wyman.trigger.http
  paths-to-match: /api/**
```

**API注解示例**:
```java
@Operation(summary = "申请证书", description = "提交CSR和ID Token申请证书")
@ApiResponse(responseCode = "200", description = "申请成功")
@ApiResponse(responseCode = "400", description = "参数错误")
@PostMapping("/apply")
public Response<CertificateIssuanceResponse> applyCertificate(
    @RequestBody @Valid CertificateApplyRequest request) {
    // ...
}
```

**访问地址**:
- Swagger UI: http://localhost:8080/swagger-ui.html
- OpenAPI JSON: http://localhost:8080/api-docs

**依赖任务**: 无
**预计工时**: 8小时
**验收标准**:
- [ ] API文档自动生成
- [ ] 文档内容完整
- [ ] 支持在线测试

---

### 8.2 部署文档 [P2]

**任务ID**: DOC-002
**描述**: 编写详细的部署文档

**文档内容**:
1. 环境要求
2. 软件依赖
3. 安装步骤
4. 配置说明
5. 启动步骤
6. 验证方法
7. 故障排查

**依赖任务**: 无
**预计工时**: 8小时
**验收标准**:
- [ ] 文档完整清晰
- [ ] 照顾单机部署
- [ ] 照顾分布式部署
- [ ] 包含故障排查

---

### 8.3 开发文档 [P2]

**任务ID**: DOC-003
**描述**: 编写开发指南

**文档内容**:
1. 项目结构说明
2. 开发环境搭建
3. 编码规范
4. Git工作流
5. 调试方法
6. 常见问题

**依赖任务**: 无
**预计工时**: 8小时
**验收标准**:
- [ ] 文档完整
- [ ] 新人可快速上手
- [ ] 包含示例代码

---

## 九、部署运维任务

### 9.1 Docker镜像构建 [P2]

**任务ID**: OPS-001
**描述**: 创建Dockerfile并构建镜像

**Dockerfile**:
```dockerfile
FROM openjdk:17-jdk-slim

WORKDIR /app

COPY target/hybird-app.jar app.jar

COPY application.yml application.yml

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]
```

**docker-compose.yml**:
```yaml
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: hybird
    ports:
      - "3306:3306"
    volumes:
      - mysql-data:/var/lib/mysql

  redis:
    image: redis:7
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data

  minio:
    image: minio/minio
    command: server /data
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - minio-data:/data

  app:
    build: .
    ports:
      - "8080:8080"
    depends_on:
      - mysql
      - redis
      - minio
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/hybird
      SPRING_DATA_REDIS_HOST: redis

volumes:
  mysql-data:
  redis-data:
  minio-data:
```

**构建命令**:
```bash
# 构建镜像
docker build -t hybird-certificate:1.0 .

# 启动服务
docker-compose up -d
```

**依赖任务**: 无
**预计工时**: 4小时
**验收标准**:
- [ ] Docker镜像构建成功
- [ ] 容器启动正常
- [ ] 服务可访问

---

### 9.2 CI/CD流水线 [P3]

**任务ID**: OPS-002
**描述**: 配置GitHub Actions或GitLab CI

**GitHub Actions示例**:
```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Set up JDK 17
      uses: actions/setup-java@v2
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Build with Maven
      run: mvn clean package

    - name: Run tests
      run: mvn test

  build:
    needs: test
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Build Docker image
      run: docker build -t hybird-certificate:${{ github.sha }} .

    - name: Push to registry
      run: |
        echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
        docker push hybird-certificate:${{ github.sha }}
```

**依赖任务**: OPS-001
**预计工时**: 8小时
**验收标准**:
- [ ] 自动构建
- [ ] 自动测试
- [ ] 自动部署

---

### 9.3 监控告警 [P2]

**任务ID**: OPS-003
**描述**: 集成Prometheus和Grafana监控

**实现方案**:
1. 添加Spring Boot Actuator
2. 配置Prometheus
3. 配置Grafana Dashboard
4. 配置告警规则

**依赖添加**:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```

**配置**:
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true
```

**Prometheus配置**:
```yaml
scrape_configs:
  - job_name: 'hybird-certificate'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['localhost:8080']
```

**Grafana Dashboard**:
- JVM指标
- HTTP请求指标
- 数据库连接池
- Redis连接
- 业务指标（证书数量、吊销数量等）

**依赖任务**: 无
**预计工时**: 16小时
**验收标准**:
- [ ] 指标采集正常
- [ ] Dashboard可视化
- [ ] 告警规则配置

---

## 十、优先级划分

### P0 - 紧急任务（必须立即完成）

| 任务ID | 任务名称 | 预计工时 |
|--------|---------|----------|
| TODO-001 | CRL更新定时任务 | 4小时 |
| SIMPL-001 | 对象存储网关 - MinIO集成 | 8小时 |
| SIMPL-003 | 证书签名 - Bouncy Castle完整实现 | 24小时 |
| SIMPL-004 | 混合证书实现 | 16小时 |
| SIMPL-005 | 公钥提取 - 从CSR中提取公钥 | 8小时 |

**P0小计**: 60小时

---

### P1 - 高优先级任务（尽快完成）

| 任务ID | 任务名称 | 预计工时 |
|--------|---------|----------|
| TODO-002 | CRL签发事件处理 - 缓存更新 | 1小时 |
| TODO-003 | 证书临期通知 - 通知服务缺失 | 16小时 |
| SIMPL-002 | 身份提供者 - LDAP/OAuth2集成 | 16小时 |
| SIMPL-009 | CSR策略验证 - 完整实现 | 8小时 |
| FEAT-003 | HSM硬件安全模块集成 | 32小时 |
| SEC-001 | HTTPS/TLS配置 | 4小时 |
| SEC-002 | API权限控制 | 16小时 |
| SEC-003 | 敏感数据加密 | 8小时 |

**P1小计**: 101小时

---

### P2 - 中优先级任务（按计划完成）

| 任务ID | 任务名称 | 预计工时 |
|--------|---------|----------|
| SIMPL-006 | 审计日志分页 - 数据库分页 | 4小时 |
| SIMPL-007 | 证书链构建 - 完整实现 | 8小时 |
| SIMPL-008 | CA状态管理 - 完整实现 | 4小时 |
| SIMPL-010 | 审计日志资源查询 - 完整实现 | 2小时 |
| CONF-001 | 启用Redis缓存 | 2小时 |
| FEAT-001 | 证书自动续期 | 16小时 |
| FEAT-002 | OCSP在线证书状态协议 | 24小时 |
| PERF-001 | 数据库索引优化 | 2小时 |
| PERF-002 | 批量操作优化 | 4小时 |
| PERF-003 | 缓存预热 | 4小时 |
| TEST-001 | 单元测试 | 40小时 |
| TEST-002 | 集成测试 | 32小时 |
| DOC-001 | API文档生成 | 8小时 |
| DOC-002 | 部署文档 | 8小时 |
| DOC-003 | 开发文档 | 8小时 |
| OPS-001 | Docker镜像构建 | 4小时 |
| OPS-003 | 监控告警 | 16小时 |

**P2小计**: 192小时

---

### P3 - 低优先级任务（有时间再做）

| 任务ID | 任务名称 | 预计工时 |
|--------|---------|----------|
| FEAT-004 | 多租户支持 | 40小时 |
| TEST-003 | 性能测试 | 16小时 |
| OPS-002 | CI/CD流水线 | 8小时 |

**P3小计**: 64小时

---

## 十一、总体统计

### 11.1 工时统计

| 优先级 | 任务数 | 预计工时 | 占比 |
|--------|--------|----------|------|
| P0 | 5 | 60小时 | 16.9% |
| P1 | 8 | 101小时 | 28.5% |
| P2 | 18 | 192小时 | 54.2% |
| P3 | 3 | 64小时 | 18.1% |
| **总计** | **34** | **417小时** | **100%** |

**按8小时工作日计算**: 约52个工作日

### 11.2 任务分类统计

| 分类 | 任务数 | 预计工时 |
|------|--------|----------|
| TODO注释任务 | 3 | 21小时 |
| 简化实现任务 | 10 | 82小时 |
| 配置优化任务 | 1 | 2小时 |
| 功能增强任务 | 4 | 112小时 |
| 性能优化任务 | 3 | 10小时 |
| 安全增强任务 | 3 | 28小时 |
| 测试任务 | 3 | 88小时 |
| 文档完善任务 | 3 | 24小时 |
| 部署运维任务 | 3 | 28小时 |
| **总计** | **33** | **395小时** |

### 11.3 按模块分类

| 模块 | 任务数 | 预计工时 |
|------|--------|----------|
| 证书管理 | 6 | 60小时 |
| 身份验证 | 1 | 16小时 |
| 签名服务 | 3 | 56小时 |
| 策略管理 | 1 | 8小时 |
| CA管理 | 1 | 4小时 |
| 审计日志 | 2 | 12小时 |
| 缓存服务 | 2 | 6小时 |
| 存储服务 | 1 | 8小时 |
| 通知服务 | 1 | 16小时 |
| 安全增强 | 3 | 28小时 |
| 性能优化 | 3 | 10小时 |
| 测试 | 3 | 88小时 |
| 文档 | 3 | 24小时 |
| 部署运维 | 3 | 28小时 |
| **总计** | **34** | **364小时** |

---

## 十二、实施计划

### 第一阶段：核心功能完善（2周）

**目标**: 完成P0级核心任务，确保系统核心功能可用

| 任务 | 负责人 | 完成时间 |
|------|--------|----------|
| TODO-001 CRL更新定时任务 | @开发者1 | 第1周 |
| SIMPL-005 公钥提取 | @开发者1 | 第1周 |
| SIMPL-003 证书签名Bouncy Castle实现 | @开发者2 | 第1-2周 |
| SIMPL-004 混合证书实现 | @开发者2 | 第2周 |
| SIMPL-001 MinIO集成 | @开发者3 | 第2周 |

**里程碑**: 核心证书签发和CRL生成功能可用

---

### 第二阶段：外部集成和安全增强（3周）

**目标**: 完成P1级任务，集成外部系统，增强安全性

| 任务 | 负责人 | 完成时间 |
|------|--------|----------|
| TODO-002 缓存更新 | @开发者1 | 第3周 |
| TODO-003 通知服务 | @开发者1 | 第3-4周 |
| SIMPL-002 LDAP/OAuth2集成 | @开发者2 | 第3-4周 |
| SIMPL-009 CSR验证 | @开发者2 | 第4周 |
| SEC-001 HTTPS配置 | @开发者3 | 第3周 |
| SEC-002 API权限控制 | @开发者3 | 第4-5周 |
| SEC-003 敏感数据加密 | @开发者3 | 第5周 |
| FEAT-003 HSM集成 | @开发者4 | 第3-5周 |

**里程碑**: 系统具备生产环境基本安全要求

---

### 第三阶段：性能优化和测试（2周）

**目标**: 完成P2级性能和测试任务

| 任务 | 负责人 | 完成时间 |
|------|--------|----------|
| CONF-001 Redis缓存 | @开发者1 | 第6周 |
| PERF-001 数据库索引 | @开发者1 | 第6周 |
| PERF-002 批量操作 | @开发者1 | 第6周 |
| PERF-003 缓存预热 | @开发者1 | 第6周 |
| TEST-001 单元测试 | @开发者2 | 第6-7周 |
| TEST-002 集成测试 | @开发者2 | 第7周 |
| SIMPL-006 审计分页 | @开发者3 | 第6周 |
| SIMPL-007 证书链构建 | @开发者3 | 第6周 |
| SIMPL-008 CA状态管理 | @开发者3 | 第6周 |
| SIMPL-010 资源查询 | @开发者3 | 第6周 |

**里程碑**: 系统性能达标，测试覆盖率>80%

---

### 第四阶段：文档和运维（2周）

**目标**: 完成文档和运维配置

| 任务 | 负责人 | 完成时间 |
|------|--------|----------|
| DOC-001 API文档 | @技术文档 | 第8周 |
| DOC-002 部署文档 | @技术文档 | 第8周 |
| DOC-003 开发文档 | @技术文档 | 第8周 |
| OPS-001 Docker镜像 | @运维工程师 | 第8周 |
| OPS-003 监控告警 | @运维工程师 | 第8周 |

**里程碑**: 系统可正式上线

---

### 第五阶段：功能增强（4周）

**目标**: 完成P2和P3级增强功能

| 任务 | 负责人 | 完成时间 |
|------|--------|----------|
| FEAT-001 证书自动续期 | @开发者1 | 第9-10周 |
| FEAT-002 OCSP协议 | @开发者2 | 第9-11周 |
| FEAT-004 多租户支持 | @开发者3 | 第10-13周 |
| TEST-003 性能测试 | @测试工程师 | 第12周 |
| OPS-002 CI/CD流水线 | @运维工程师 | 第13周 |

**里程碑**: 系统功能完整，具备扩展能力

---

## 十三、风险评估

### 高风险项

1. **Bouncy Castle混合签名实现** (SIMPL-003)
   - 风险: ML-DSA算法支持不完善
   - 缓解: 提前验证Bouncy Castle版本，必要时使用其他库

2. **HSM硬件集成** (FEAT-003)
   - 风险: 不同厂商HSM接口差异大
   - 缓解: 选择成熟厂商，提前获取测试环境

3. **混合证书标准不统一** (SIMPL-004)
   - 风险: 混合证书格式可能不符合行业标准
   - 缓解: 参考IETF RFC草案，与第三方CA互通测试

### 中风险项

4. **LDAP/OAuth2集成** (SIMPL-002)
   - 风险: 不同身份提供者配置差异大
   - 缓解: 支持多种认证方式，提供配置示例

5. **OCSP协议实现** (FEAT-002)
   - 风险: 协议复杂，实现难度大
   - 缓解: 使用成熟的Bouncy Castle OCSP支持

6. **多租户数据隔离** (FEAT-004)
   - 风险: 隔离不彻底导致数据泄露
   - 缓解: 严格的代码审查，安全测试

---

## 十四、注意事项

1. **任务依赖关系**: 严格按照依赖顺序执行
2. **代码审查**: 所有代码合并前必须经过Code Review
3. **测试覆盖**: 功能上线前必须有相应的测试用例
4. **文档更新**: 功能变更同步更新相关文档
5. **性能监控**: 新功能上线后监控性能指标
6. **安全审计**: 定期进行安全审计和漏洞扫描
7. **版本管理**: 使用Git进行版本控制，合理使用分支策略

---

## 十五、附录

### 15.1 术语表

| 术语 | 说明 |
|------|------|
| CSR | Certificate Signing Request，证书签名请求 |
| CRL | Certificate Revocation List，证书吊销列表 |
| OCSP | Online Certificate Status Protocol，在线证书状态协议 |
| HSM | Hardware Security Module，硬件安全模块 |
| PQC | Post-Quantum Cryptography，后量子密码学 |
| DDD | Domain-Driven Design，领域驱动设计 |

### 15.2 参考资料

1. RFC 5280 - Internet X.509 PKI Certificate and CRL Profile
2. RFC 6960 - X.509 Internet Public Key Infrastructure Online Certificate Status Protocol
3. NIST FIPS 203 - Module-Lattice-Based KEM Standard
4. NIST FIPS 204 - Module-Lattice-Based Digital Signature Standard
5. GB/T 35275-2017 - SM2密码算法使用规范
6. Spring Boot Reference Documentation
7. Bouncy Castle Documentation

---

**文档结束**

**修订历史**:

| 版本 | 修订日期 | 修订人 | 修订内容 |
|------|---------|--------|---------|
| V1.0 | 2025-01-04 | 开发团队 | 初始版本 |
